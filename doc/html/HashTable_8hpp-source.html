<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>HashTable.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.16 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>HashTable.hpp</h1><a href="HashTable_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*==========================================================================</font>
00002 <font class="comment">  Copyright (c) 2004 University of Massachusetts.  All Rights Reserved.</font>
00003 <font class="comment"></font>
00004 <font class="comment">  Use of the Lemur Toolkit for Language Modeling and Information Retrieval</font>
00005 <font class="comment">  is subject to the terms of the software license set forth in the LICENSE</font>
00006 <font class="comment">  file included with this software, and also available at</font>
00007 <font class="comment">  http://www.cs.cmu.edu/~lemur/license.html </font>
00008 <font class="comment">  as well as the conditions below.</font>
00009 <font class="comment"></font>
00010 <font class="comment">  Redistribution and use in source and binary forms, with or without</font>
00011 <font class="comment">  modification, are permitted provided that the following conditions</font>
00012 <font class="comment">  are met:</font>
00013 <font class="comment"></font>
00014 <font class="comment">  1. Redistributions of source code must retain the above copyright</font>
00015 <font class="comment">  notice, this list of conditions and the following disclaimer.</font>
00016 <font class="comment"></font>
00017 <font class="comment">  2. Redistributions in binary form must reproduce the above copyright</font>
00018 <font class="comment">  notice, this list of conditions and the following disclaimer in</font>
00019 <font class="comment">  the documentation and/or other materials provided with the</font>
00020 <font class="comment">  distribution.</font>
00021 <font class="comment"></font>
00022 <font class="comment">  3. The names "Indri", "Center for Intelligent Information Retrieval", </font>
00023 <font class="comment">  "CIIR", and "University of Massachusetts" must not be used to</font>
00024 <font class="comment">  endorse or promote products derived from this software without</font>
00025 <font class="comment">  prior written permission. To obtain permission, contact</font>
00026 <font class="comment">  indri-info@ciir.cs.umass.edu.</font>
00027 <font class="comment"></font>
00028 <font class="comment">  4. Products derived from this software may not be called "Indri" nor </font>
00029 <font class="comment">  may "Indri" appear in their names without prior written permission of </font>
00030 <font class="comment">  the University of Massachusetts. To obtain permission, contact </font>
00031 <font class="comment">  indri-info@ciir.cs.umass.edu.</font>
00032 <font class="comment"></font>
00033 <font class="comment">  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF MASSACHUSETTS AND OTHER</font>
00034 <font class="comment">  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,</font>
00035 <font class="comment">  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND</font>
00036 <font class="comment">  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</font>
00037 <font class="comment">  THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</font>
00038 <font class="comment">  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</font>
00039 <font class="comment">  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS</font>
00040 <font class="comment">  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED</font>
00041 <font class="comment">  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</font>
00042 <font class="comment">  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF</font>
00043 <font class="comment">  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</font>
00044 <font class="comment">  DAMAGE.</font>
00045 <font class="comment">  ==========================================================================</font>
00046 <font class="comment">*/</font>
00047 
00048 
00049 <font class="comment">//</font>
00050 <font class="comment">// HashTable</font>
00051 <font class="comment">//</font>
00052 <font class="comment">// 9 January 2004 - tds</font>
00053 <font class="comment">//</font>
00054 
00055 <font class="preprocessor">#ifndef LEMUR_HASHTABLE_HPP</font>
00056 <font class="preprocessor"></font><font class="preprocessor">#define LEMUR_HASHTABLE_HPP</font>
00057 <font class="preprocessor"></font>
00058 <font class="preprocessor">#include &lt;utility&gt;</font>
00059 
00060 <font class="comment">//</font>
00061 <font class="comment">// GenericHash&lt;_Key&gt;</font>
00062 <font class="comment">//</font>
00063 
00064 <font class="keyword">template</font>&lt;<font class="keyword">class</font> _Key&gt;
<a name="l00065"></a><a class="code" href="classGenericHash.html">00065</a> <font class="keyword">class </font><a class="code" href="classGenericHash.html">GenericHash</a> { 
00066 <font class="keyword">public</font>:
<a name="l00067"></a><a class="code" href="classGenericHash.html#a0">00067</a>   <font class="keywordtype">int</font> <a class="code" href="classGenericHash.html#a0">operator() </a>( <font class="keyword">const</font> _Key&amp; k )<font class="keyword"> const </font>{
00068     <font class="keywordflow">return</font> (int) k;
00069   }
00070 };
00071 
00072 <font class="comment">//</font>
00073 <font class="comment">// GenericComparator&lt;_Key&gt;</font>
00074 <font class="comment">//</font>
00075 
00076 <font class="keyword">template</font>&lt;<font class="keyword">class</font> _Key&gt;
<a name="l00077"></a><a class="code" href="classGenericComparator.html">00077</a> <font class="keyword">class </font><a class="code" href="classGenericComparator.html">GenericComparator</a> {
00078 <font class="keyword">public</font>:
<a name="l00079"></a><a class="code" href="classGenericComparator.html#a0">00079</a>   <font class="keywordtype">int</font> <a class="code" href="classGenericComparator.html#a0">operator() </a>( <font class="keyword">const</font> _Key&amp; one, <font class="keyword">const</font> _Key&amp; two )<font class="keyword"> const </font>{
00080     <font class="keywordflow">return</font> (int) (one - two);
00081   }
00082 };
00083 
00084 <font class="keyword">template</font>&lt;&gt;
<a name="l00085"></a><a class="code" href="classGenericHash_3_01const_01char_01_5_01_4.html">00085</a> <font class="keyword">class </font><a class="code" href="classGenericHash.html">GenericHash</a>&lt;const char*&gt; {
00086 <font class="keyword">public</font>:
<a name="l00087"></a><a class="code" href="classGenericHash_3_01const_01char_01_5_01_4.html#a0">00087</a>   <font class="keywordtype">int</font> <a class="code" href="classGenericHash.html#a0">operator() </a>( <font class="keyword">const</font> <font class="keywordtype">char</font>* <font class="keyword">const</font>&amp; kp )<font class="keyword"> const </font>{
00088     <font class="keywordtype">int</font> hash = 0;
00089     <font class="keyword">const</font> <font class="keywordtype">char</font>* k = kp;
00090     <font class="keywordflow">for</font>( ; *k; k++ ){
00091       hash *= 7;
00092       hash += *k;
00093     }
00094     <font class="keywordflow">return</font> hash;
00095   }
00096 };
00097 
00098 <font class="keyword">template</font>&lt;&gt;
<a name="l00099"></a><a class="code" href="classGenericComparator_3_01const_01char_01_5_01_4.html">00099</a> <font class="keyword">class </font><a class="code" href="classGenericComparator.html">GenericComparator</a>&lt;const char*&gt; {
00100 <font class="keyword">public</font>:
<a name="l00101"></a><a class="code" href="classGenericComparator_3_01const_01char_01_5_01_4.html#a0">00101</a>   <font class="keywordtype">int</font> <a class="code" href="classGenericComparator.html#a0">operator () </a>( <font class="keyword">const</font> <font class="keywordtype">char</font>* <font class="keyword">const</font>&amp; one, <font class="keyword">const</font> <font class="keywordtype">char</font>* <font class="keyword">const</font>&amp; two )<font class="keyword"> const </font>{
00102     <font class="keywordflow">return</font> strcmp( one, two );
00103   }
00104 };
00105 
00106 <font class="comment">//</font>
00107 <font class="comment">// HashBucket&lt;_Key, _Value&gt;</font>
00108 <font class="comment">//</font>
00109 
00110 <font class="keyword">template</font>&lt;<font class="keyword">class</font> _Key, <font class="keyword">class</font> _Value&gt;
<a name="l00111"></a><a class="code" href="structHashBucket.html">00111</a> <font class="keyword">struct </font><a class="code" href="structHashBucket.html">HashBucket</a> {
<a name="l00112"></a><a class="code" href="structHashBucket.html#m0">00112</a>   _Key <a class="code" href="structHashBucket.html#m0">key</a>;
<a name="l00113"></a><a class="code" href="structHashBucket.html#m1">00113</a>   _Value <a class="code" href="structHashBucket.html#m1">value</a>;
<a name="l00114"></a><a class="code" href="structHashBucket.html#m2">00114</a>   <a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a>* <a class="code" href="structHashBucket.html#m2">next</a>;
00115 
<a name="l00116"></a><a class="code" href="structHashBucket.html#a0">00116</a>   <a class="code" href="structHashBucket.html#a0">HashBucket</a>() : next( (<a class="code" href="structHashBucket.html">HashBucket</a>&lt;_Key, _Value&gt;*) ~0 ) {};
<a name="l00117"></a><a class="code" href="structHashBucket.html#a1">00117</a>   <a class="code" href="structHashBucket.html#a0">HashBucket</a>( <font class="keyword">const</font> _Key&amp; k, <a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a>* n ) : <a class="code" href="structHashBucket.html#m0">key</a>(k), next(n) {};
<a name="l00118"></a><a class="code" href="structHashBucket.html#a2">00118</a>   <a class="code" href="structHashBucket.html#a0">HashBucket</a>( <font class="keyword">const</font> _Key&amp; k, <font class="keyword">const</font> _Value&amp; v, <a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a>* n ) : <a class="code" href="structHashBucket.html#m0">key</a>(k), <a class="code" href="structHashBucket.html#m1">value</a>(v), next(n) {};
00119   
<a name="l00120"></a><a class="code" href="structHashBucket.html#a3">00120</a>   <a class="code" href="structHashBucket.html#a3">~HashBucket</a>() {
00121     next = (<a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a>*) ~0;
00122   }
00123 
<a name="l00124"></a><a class="code" href="structHashBucket.html#a4">00124</a>   <font class="keywordtype">bool</font> <a class="code" href="structHashBucket.html#a4">empty</a>() {
00125     <font class="keywordflow">return</font> next == (<a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a>*) ~0;
00126   }
00127 
<a name="l00128"></a><a class="code" href="structHashBucket.html#a5">00128</a>   <font class="keywordtype">void</font> <a class="code" href="structHashBucket.html#a5">setEmpty</a>() {
00129     next = (<a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a>*) ~0;
00130   }
00131 };
00132 
00133 <font class="comment">//</font>
00134 <font class="comment">// HashTableIterator&lt;_Key, _Value, _Comparator&gt;</font>
00135 <font class="comment">//</font>
00136 
00137 <font class="keyword">template</font>&lt;<font class="keyword">class</font> _Key, <font class="keyword">class</font> _Value, <font class="keyword">class</font> _Comparator&gt;
<a name="l00138"></a><a class="code" href="classHashTableIterator.html">00138</a> <font class="keyword">class </font><a class="code" href="classHashTableIterator.html">HashTableIterator</a> {
00139 <font class="keyword">private</font>:
<a name="l00140"></a><a class="code" href="classHashTableIterator.html#u0">00140</a>   <font class="keyword">typedef</font> <a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a> <a class="code" href="structHashBucket.html">bucket_type</a>;
<a name="l00141"></a><a class="code" href="classHashTableIterator.html#o0">00141</a>   bucket_type* <a class="code" href="classHashTableIterator.html#o0">_table</a>;
<a name="l00142"></a><a class="code" href="classHashTableIterator.html#o1">00142</a>   bucket_type* <a class="code" href="classHashTableIterator.html#o1">_currentEntry</a>;
<a name="l00143"></a><a class="code" href="classHashTableIterator.html#o2">00143</a>   size_t <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a>;
<a name="l00144"></a><a class="code" href="classHashTableIterator.html#o3">00144</a>   size_t <a class="code" href="classHashTableIterator.html#o3">_totalBuckets</a>;
<a name="l00145"></a><a class="code" href="classHashTableIterator.html#o4">00145</a>   std::pair&lt;_Key*, _Value*&gt; <a class="code" href="classHashTableIterator.html#o4">_pair</a>;
00146 
<a name="l00147"></a><a class="code" href="classHashTableIterator.html#c0">00147</a>   <font class="keywordtype">void</font> <a class="code" href="classHashTableIterator.html#c0">next</a>() {
00148     <font class="comment">// already at end</font>
00149     <font class="keywordflow">if</font>( <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> == -1 )
00150       <font class="keywordflow">return</font>;
00151 
00152     <font class="comment">// in a chain with more entries left</font>
00153     <font class="keywordflow">if</font>( _currentEntry &amp;&amp; _currentEntry-&gt;<a class="code" href="structHashBucket.html#m2">next</a> != 0 ) {
00154       _currentEntry = _currentEntry-&gt;<a class="code" href="structHashBucket.html#m2">next</a>;
00155       <font class="keywordflow">return</font>;
00156     }
00157 
00158     <font class="keywordflow">if</font>( _currentEntry )
00159       <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a>++;
00160 
00161     <font class="keywordflow">for</font>( ; <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> &lt; <a class="code" href="classHashTableIterator.html#o3">_totalBuckets</a>; <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a>++ ) {
00162       _currentEntry = &amp;_table[<a class="code" href="classHashTableIterator.html#o2">_currentBucket</a>];
00163 
00164       <font class="keywordflow">if</font>( ! _currentEntry-&gt;<a class="code" href="structHashBucket.html#a4">empty</a>() ) {
00165         <font class="keywordflow">return</font>;
00166       }
00167     }
00168 
00169     <font class="comment">// none left</font>
00170     _currentEntry = 0;
00171     <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> = -1;
00172   }
00173 
00174 <font class="keyword">public</font>:
<a name="l00175"></a><a class="code" href="classHashTableIterator.html#a0">00175</a>   <a class="code" href="classHashTableIterator.html#a0">HashTableIterator</a>() {
00176     <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> = -1;
00177     _currentEntry = 0;
00178   }
00179 
<a name="l00180"></a><a class="code" href="classHashTableIterator.html#a1">00180</a>   <a class="code" href="classHashTableIterator.html#a0">HashTableIterator</a>( bucket_type* table, size_t totalBuckets ) {
00181     _table = table;
00182     <a class="code" href="classHashTableIterator.html#o3">_totalBuckets</a> = totalBuckets;
00183 
00184     <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> = 0;
00185     _currentEntry = 0;
00186     <a class="code" href="classHashTableIterator.html#c0">next</a>();
00187   }
00188 
<a name="l00189"></a><a class="code" href="classHashTableIterator.html#a2">00189</a>   <font class="keywordtype">bool</font> <a class="code" href="classHashTableIterator.html#a2">operator == </a>( <font class="keyword">const</font> <a class="code" href="classHashTableIterator.html">HashTableIterator</a>&amp; other ) {
00190     <font class="keywordflow">if</font>( other.<a class="code" href="classHashTableIterator.html#o1">_currentEntry</a> == _currentEntry &amp;&amp;
00191         other.<a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> == <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> )
00192         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00193     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00194   }
00195 
<a name="l00196"></a><a class="code" href="classHashTableIterator.html#a3">00196</a>   <font class="keywordtype">bool</font> <a class="code" href="classHashTableIterator.html#a3">operator != </a>( <font class="keyword">const</font> <a class="code" href="classHashTableIterator.html">HashTableIterator</a>&amp; other ) {
00197     <font class="keywordflow">if</font>( other.<a class="code" href="classHashTableIterator.html#o1">_currentEntry</a> == _currentEntry &amp;&amp;
00198         other.<a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> == <a class="code" href="classHashTableIterator.html#o2">_currentBucket</a> )
00199         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00200     <font class="keywordflow">return</font> <font class="keyword">true</font>;
00201   }
00202 
<a name="l00203"></a><a class="code" href="classHashTableIterator.html#a4">00203</a>   <font class="keywordtype">void</font> <a class="code" href="classHashTableIterator.html#a4">operator++ </a>( <font class="keywordtype">int</font> ) {
00204     <a class="code" href="classHashTableIterator.html#c0">next</a>();
00205   }
00206 
<a name="l00207"></a><a class="code" href="classHashTableIterator.html#a5">00207</a>   std::pair&lt;_Key*, _Value*&gt;&amp; <a class="code" href="classHashTableIterator.html#a5">operator* </a>() {
00208     <a class="code" href="classHashTableIterator.html#o4">_pair</a>.first = &amp;_currentEntry-&gt;<a class="code" href="structHashBucket.html#m0">key</a>;
00209     <a class="code" href="classHashTableIterator.html#o4">_pair</a>.second = &amp;_currentEntry-&gt;<a class="code" href="structHashBucket.html#m1">value</a>;
00210     <font class="keywordflow">return</font> <a class="code" href="classHashTableIterator.html#o4">_pair</a>;
00211   }
00212 
<a name="l00213"></a><a class="code" href="classHashTableIterator.html#a6">00213</a>   std::pair&lt;_Key*, _Value*&gt;* <a class="code" href="classHashTableIterator.html#a6">operator-&gt; </a>() {
00214     <font class="keywordflow">return</font> &amp;(*(*this));
00215   }
00216 };
00217 
00218 <font class="keyword">template</font>&lt;<font class="keyword">class</font> _Key, <font class="keyword">class</font> _Value, <font class="keyword">class</font> _HashFunction = GenericHash&lt;_Key&gt;, <font class="keyword">class</font> _Comparator = GenericComparator&lt;_Key&gt; &gt;
<a name="l00219"></a><a class="code" href="classHashTable.html">00219</a> <font class="keyword">class </font><a class="code" href="classHashTable.html">HashTable</a> {
00220 <font class="keyword">public</font>:
<a name="l00221"></a><a class="code" href="classHashTable.html#l0">00221</a>   <font class="keyword">friend</font> <font class="keyword">class </font><a class="code" href="classHashTableIterator.html">HashTableIterator</a>&lt;_Key, _Value, _Comparator&gt;;
00222 
<a name="l00223"></a><a class="code" href="classHashTable.html#s0">00223</a>   <font class="keyword">typedef</font> <a class="code" href="structHashBucket.html">HashBucket&lt;_Key, _Value&gt;</a> <a class="code" href="structHashBucket.html">bucket_type</a>;
<a name="l00224"></a><a class="code" href="classHashTable.html#s1">00224</a>   <font class="keyword">typedef</font> _Key <a class="code" href="classHashTable.html#s1">key_type</a>;
<a name="l00225"></a><a class="code" href="classHashTable.html#s2">00225</a>   <font class="keyword">typedef</font> _Value <a class="code" href="classHashTable.html#s2">value_type</a>;
<a name="l00226"></a><a class="code" href="classHashTable.html#s3">00226</a>   <font class="keyword">typedef</font> _HashFunction <a class="code" href="classGenericHash_3_01const_01char_01_5_01_4.html">hash_type</a>;
<a name="l00227"></a><a class="code" href="classHashTable.html#s4">00227</a>   <font class="keyword">typedef</font> _Comparator <a class="code" href="classGenericComparator_3_01const_01char_01_5_01_4.html">compare_type</a>;
<a name="l00228"></a><a class="code" href="classHashTable.html#s5">00228</a>   <font class="keyword">typedef</font> <font class="keyword">class </font><a class="code" href="classHashTableIterator.html">HashTableIterator</a>&lt;_Key, _Value, _Comparator&gt; iterator;
00229 
00230 <font class="keyword">private</font>:
<a name="l00231"></a><a class="code" href="classHashTable.html#o0">00231</a>   <a class="code" href="structHashBucket.html">bucket_type</a>* <a class="code" href="classHashTable.html#o0">_table</a>;
<a name="l00232"></a><a class="code" href="classHashTable.html#o1">00232</a>   <a class="code" href="classGenericHash_3_01const_01char_01_5_01_4.html">hash_type</a> <a class="code" href="classHashTable.html#o1">_hash</a>;
<a name="l00233"></a><a class="code" href="classHashTable.html#o2">00233</a>   <a class="code" href="classGenericComparator_3_01const_01char_01_5_01_4.html">compare_type</a> <a class="code" href="classHashTable.html#o2">_compare</a>;
<a name="l00234"></a><a class="code" href="classHashTable.html#o3">00234</a>   size_t <a class="code" href="classHashTable.html#o3">_buckets</a>;
<a name="l00235"></a><a class="code" href="classHashTable.html#o4">00235</a>   iterator <a class="code" href="classHashTable.html#o4">_end</a>;
<a name="l00236"></a><a class="code" href="classHashTable.html#o5">00236</a>   size_t <a class="code" href="classHashTable.html#o5">_count</a>;
00237 
<a name="l00238"></a><a class="code" href="classHashTable.html#c0">00238</a>   <a class="code" href="structHashBucket.html">bucket_type</a>* <a class="code" href="classHashTable.html#c0">_parentBucket</a>( <font class="keyword">const</font> _Key&amp; k )<font class="keyword"> const </font>{
00239     size_t index = <a class="code" href="classHashTable.html#o1">_hash</a>(k) % <a class="code" href="classHashTable.html#o3">_buckets</a>;
00240     <font class="keywordflow">return</font> &amp;_table[index];
00241   }
00242 
00243 <font class="keyword">public</font>:
<a name="l00244"></a><a class="code" href="classHashTable.html#a0">00244</a>   <a class="code" href="classHashTable.html#a0">HashTable</a>( size_t <a class="code" href="classHashTable.html#a9">size</a> = 16384 ) {
00245     <a class="code" href="classHashTable.html#o3">_buckets</a> = <a class="code" href="classHashTable.html#a9">size</a> / <font class="keyword">sizeof</font>(bucket_type);
00246     _table = reinterpret_cast&lt;bucket_type*&gt;(<font class="keyword">new</font> <font class="keywordtype">char</font>[<a class="code" href="classHashTable.html#o3">_buckets</a> * <font class="keyword">sizeof</font>(bucket_type)]);
00247     <a class="code" href="classHashTable.html#o5">_count</a> = 0;
00248     
00249     <font class="keywordflow">for</font>( size_t i=0; i&lt;<a class="code" href="classHashTable.html#o3">_buckets</a>; i++ ) {
00250       _table[i].<a class="code" href="structHashBucket.html#a5">setEmpty</a>();
00251     }
00252   }
00253 
<a name="l00254"></a><a class="code" href="classHashTable.html#a1">00254</a>   <a class="code" href="classHashTable.html#a1">~HashTable</a>() {
00255     <a class="code" href="classHashTable.html#a6">clear</a>();
00256     <font class="keyword">delete</font>[] reinterpret_cast&lt;char*&gt;(_table);
00257   }
00258 
<a name="l00259"></a><a class="code" href="classHashTable.html#a2">00259</a>   _Value* <a class="code" href="classHashTable.html#a2">find</a>( <font class="keyword">const</font> _Key&amp; k )<font class="keyword"> const </font>{
00260     <a class="code" href="structHashBucket.html">bucket_type</a>* bucket = <a class="code" href="classHashTable.html#c0">_parentBucket</a>(k);
00261 
00262     <font class="keywordflow">if</font>( bucket-&gt;<a class="code" href="structHashBucket.html#a4">empty</a>() ) {
00263       <font class="keywordflow">return</font> 0;
00264     } <font class="keywordflow">else</font> {
00265       <font class="keywordflow">while</font>(1) {
00266         <font class="keywordflow">if</font>( <a class="code" href="classHashTable.html#o2">_compare</a>( k, bucket-&gt;<a class="code" href="structHashBucket.html#m0">key</a> ) == 0 ) {
00267             <font class="keywordflow">return</font> &amp;bucket-&gt;<a class="code" href="structHashBucket.html#m1">value</a>;
00268         }
00269         
00270         <font class="keywordflow">if</font>( bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a> == 0 )
00271           <font class="keywordflow">return</font> 0;
00272         <font class="keywordflow">else</font>
00273           bucket = bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a>;
00274       }
00275     }
00276   }
00277 
<a name="l00278"></a><a class="code" href="classHashTable.html#a3">00278</a>   _Value* <a class="code" href="classHashTable.html#a3">insert</a>( <font class="keyword">const</font> _Key&amp; k ) {
00279     <a class="code" href="structHashBucket.html">bucket_type</a>* bucket = <a class="code" href="classHashTable.html#c0">_parentBucket</a>(k);
00280     <a class="code" href="classHashTable.html#o5">_count</a>++;
00281 
00282     <font class="keywordflow">if</font>( bucket-&gt;<a class="code" href="structHashBucket.html#a4">empty</a>() ) {
00283       <font class="keyword">new</font>(bucket) <a class="code" href="classHashTable.html#s0">bucket_type</a>( k, 0 );
00284       <font class="keywordflow">return</font> &amp;bucket-&gt;<a class="code" href="structHashBucket.html#m1">value</a>;
00285     } <font class="keywordflow">else</font> {
00286       <a class="code" href="structHashBucket.html">bucket_type</a>* newBucket = <font class="keyword">new</font> <a class="code" href="classHashTable.html#s0">bucket_type</a>( k, bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a> );
00287       bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a> = newBucket;
00288       <font class="keywordflow">return</font> &amp;newBucket-&gt;<a class="code" href="structHashBucket.html#m1">value</a>;
00289     }
00290   }
00291 
<a name="l00292"></a><a class="code" href="classHashTable.html#a4">00292</a>   _Value* <a class="code" href="classHashTable.html#a3">insert</a>( <font class="keyword">const</font> _Key&amp; k, <font class="keyword">const</font> _Value&amp; v ) {
00293     <a class="code" href="structHashBucket.html">bucket_type</a>* bucket = <a class="code" href="classHashTable.html#c0">_parentBucket</a>(k);
00294     <a class="code" href="classHashTable.html#o5">_count</a>++;
00295 
00296     <font class="keywordflow">if</font>( bucket-&gt;<a class="code" href="structHashBucket.html#a4">empty</a>() ) {
00297       <font class="keyword">new</font>(bucket) <a class="code" href="classHashTable.html#s0">bucket_type</a>( k, v, 0 );
00298       <font class="keywordflow">return</font> &amp;bucket-&gt;<a class="code" href="structHashBucket.html#m1">value</a>;
00299     } <font class="keywordflow">else</font> {
00300       <a class="code" href="structHashBucket.html">bucket_type</a>* newBucket = <font class="keyword">new</font> <a class="code" href="classHashTable.html#s0">bucket_type</a>( k, v, bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a> );
00301       bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a> = newBucket;
00302       <font class="keywordflow">return</font> &amp;newBucket-&gt;<a class="code" href="structHashBucket.html#m1">value</a>;
00303     }
00304   }
00305 
<a name="l00306"></a><a class="code" href="classHashTable.html#a5">00306</a>   <font class="keywordtype">void</font> <a class="code" href="classHashTable.html#a5">remove</a>( <font class="keyword">const</font> _Key&amp; k ) {
00307     <a class="code" href="structHashBucket.html">bucket_type</a>* bucket = <a class="code" href="classHashTable.html#c0">_parentBucket</a>(k);
00308 
00309     <font class="keywordflow">if</font>( !bucket-&gt;<a class="code" href="structHashBucket.html#a4">empty</a>() ) {
00310       <font class="keywordflow">if</font>( <a class="code" href="classHashTable.html#o2">_compare</a>( k, bucket-&gt;<a class="code" href="structHashBucket.html#m0">key</a> ) == 0 ) {
00311         <font class="keywordflow">if</font>( bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a> ) {
00312           <a class="code" href="structHashBucket.html">bucket_type</a>* nextBucket = bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a>;
00313           bucket-&gt;~bucket_type();
00314           <font class="keyword">new</font>(bucket) <a class="code" href="classHashTable.html#s0">bucket_type</a>( nextBucket-&gt;<a class="code" href="structHashBucket.html#m0">key</a>, nextBucket-&gt;<a class="code" href="structHashBucket.html#m1">value</a>, nextBucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a> );
00315           <font class="keyword">delete</font> nextBucket;
00316         } <font class="keywordflow">else</font> {
00317           bucket-&gt;~bucket_type();
00318         }
00319         <a class="code" href="classHashTable.html#o5">_count</a>--;
00320       } <font class="keywordflow">else</font> {
00321         <a class="code" href="structHashBucket.html">bucket_type</a>* parent = bucket;
00322         bucket = parent-&gt;<a class="code" href="structHashBucket.html#m2">next</a>;
00323 
00324         <font class="keywordflow">while</font>( bucket ) {
00325           <font class="keywordflow">if</font>( <a class="code" href="classHashTable.html#o2">_compare</a>( k, bucket-&gt;<a class="code" href="structHashBucket.html#m0">key</a> ) == 0 ) {
00326             <a class="code" href="classHashTable.html#o5">_count</a>--;
00327             parent-&gt;<a class="code" href="structHashBucket.html#m2">next</a> = bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a>;
00328             <font class="keyword">delete</font> bucket;
00329             <font class="keywordflow">break</font>;
00330           }
00331           parent = bucket;
00332           bucket = bucket-&gt;<a class="code" href="structHashBucket.html#m2">next</a>;
00333         }
00334       }
00335     }
00336   }
00337 
<a name="l00338"></a><a class="code" href="classHashTable.html#a6">00338</a>   <font class="keywordtype">void</font> <a class="code" href="classHashTable.html#a6">clear</a>() {
00339     <font class="keywordflow">for</font>( size_t i=0; i&lt;<a class="code" href="classHashTable.html#o3">_buckets</a>; i++ ) {
00340       <font class="keywordflow">if</font>( !_table[i].<a class="code" href="structHashBucket.html#a4">empty</a>() ) {
00341         <a class="code" href="structHashBucket.html">bucket_type</a>* current = _table[i].<a class="code" href="structHashBucket.html#m2">next</a>;
00342         <a class="code" href="structHashBucket.html">bucket_type</a>* next;
00343 
00344         _table[i].~bucket_type();
00345 
00346         <font class="keywordflow">while</font>( current ) {
00347           next = current-&gt;<a class="code" href="structHashBucket.html#m2">next</a>;
00348           <font class="keyword">delete</font> current;
00349           current = next;
00350         }
00351       }
00352     }
00353     <a class="code" href="classHashTable.html#o5">_count</a> = 0;
00354   }
00355 
<a name="l00356"></a><a class="code" href="classHashTable.html#a7">00356</a>   <font class="keyword">const</font> iterator&amp; <a class="code" href="classHashTable.html#a7">end</a>() {
00357     <font class="keywordflow">return</font> _end;
00358   }
00359 
<a name="l00360"></a><a class="code" href="classHashTable.html#a8">00360</a>   iterator <a class="code" href="classHashTable.html#a8">begin</a>() {
00361     <font class="keywordflow">return</font> <a class="code" href="classHashTable.html#s5">iterator</a>( _table, <a class="code" href="classHashTable.html#o3">_buckets</a> );
00362   }
00363 
<a name="l00364"></a><a class="code" href="classHashTable.html#a9">00364</a>   size_t <a class="code" href="classHashTable.html#a9">size</a>() {
00365     <font class="keywordflow">return</font> <a class="code" href="classHashTable.html#o5">_count</a>;
00366   }
00367 };
00368 
00369 <font class="preprocessor">#endif // LEMUR_HASHTABLE_HPP</font>
</pre></div><hr><address align="right"><small>Generated on Tue Nov 16 15:17:21 2004 for INDRI by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.16 </small></address>
</body>
</html>
