<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Parameters.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.16 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Parameters.hpp</h1><a href="Parameters_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*==========================================================================</font>
00002 <font class="comment">  Copyright (c) 2004 University of Massachusetts.  All Rights Reserved.</font>
00003 <font class="comment"></font>
00004 <font class="comment">  Use of the Lemur Toolkit for Language Modeling and Information Retrieval</font>
00005 <font class="comment">  is subject to the terms of the software license set forth in the LICENSE</font>
00006 <font class="comment">  file included with this software, and also available at</font>
00007 <font class="comment">  http://www.cs.cmu.edu/~lemur/license.html </font>
00008 <font class="comment">  as well as the conditions below.</font>
00009 <font class="comment"></font>
00010 <font class="comment">  Redistribution and use in source and binary forms, with or without</font>
00011 <font class="comment">  modification, are permitted provided that the following conditions</font>
00012 <font class="comment">  are met:</font>
00013 <font class="comment"></font>
00014 <font class="comment">  1. Redistributions of source code must retain the above copyright</font>
00015 <font class="comment">  notice, this list of conditions and the following disclaimer.</font>
00016 <font class="comment"></font>
00017 <font class="comment">  2. Redistributions in binary form must reproduce the above copyright</font>
00018 <font class="comment">  notice, this list of conditions and the following disclaimer in</font>
00019 <font class="comment">  the documentation and/or other materials provided with the</font>
00020 <font class="comment">  distribution.</font>
00021 <font class="comment"></font>
00022 <font class="comment">  3. The names "Indri", "Center for Intelligent Information Retrieval", </font>
00023 <font class="comment">  "CIIR", and "University of Massachusetts" must not be used to</font>
00024 <font class="comment">  endorse or promote products derived from this software without</font>
00025 <font class="comment">  prior written permission. To obtain permission, contact</font>
00026 <font class="comment">  indri-info@ciir.cs.umass.edu.</font>
00027 <font class="comment"></font>
00028 <font class="comment">  4. Products derived from this software may not be called "Indri" nor </font>
00029 <font class="comment">  may "Indri" appear in their names without prior written permission of </font>
00030 <font class="comment">  the University of Massachusetts. To obtain permission, contact </font>
00031 <font class="comment">  indri-info@ciir.cs.umass.edu.</font>
00032 <font class="comment"></font>
00033 <font class="comment">  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF MASSACHUSETTS AND OTHER</font>
00034 <font class="comment">  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,</font>
00035 <font class="comment">  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND</font>
00036 <font class="comment">  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</font>
00037 <font class="comment">  THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</font>
00038 <font class="comment">  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,</font>
00039 <font class="comment">  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS</font>
00040 <font class="comment">  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED</font>
00041 <font class="comment">  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</font>
00042 <font class="comment">  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF</font>
00043 <font class="comment">  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</font>
00044 <font class="comment">  DAMAGE.</font>
00045 <font class="comment">  ==========================================================================</font>
00046 <font class="comment">*/</font>
00047 
00048 
00049 <font class="comment">//</font>
00050 <font class="comment">// Parameters</font>
00051 <font class="comment">//</font>
00052 <font class="comment">// 29 April 2004 -- tds</font>
00053 <font class="comment">//</font>
00054 
00055 <font class="preprocessor">#ifndef INDRI_PARAMETERS_HPP</font>
00056 <font class="preprocessor"></font><font class="preprocessor">#define INDRI_PARAMETERS_HPP</font>
00057 <font class="preprocessor"></font>
00058 <font class="preprocessor">#include &lt;string&gt;</font>
00059 <font class="preprocessor">#include "<a class="code" href="XMLNode_8hpp.html">indri/XMLNode.hpp</a>"</font>
00060 <font class="preprocessor">#include "<a class="code" href="delete__range_8hpp.html">indri/delete_range.hpp</a>"</font>
00061 
<a name="l00067"></a><a class="code" href="classParameters.html">00067</a> <font class="keyword">class </font><a class="code" href="classParameters.html">Parameters</a> {
00068 <font class="keyword">public</font>:
<a name="l00070"></a><a class="code" href="structParameters_1_1parameter__value.html">00070</a>   <font class="keyword">struct </font><a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a> {
<a name="l00071"></a><a class="code" href="structParameters_1_1parameter__value.html#s0">00071</a>     <font class="keyword">typedef</font> std::map&lt;std::string, parameter_value*&gt; <a class="code" href="structParameters_1_1parameter__value.html#s0">MValue</a>;
<a name="l00073"></a><a class="code" href="structParameters_1_1parameter__value.html#m0">00073</a>     <a class="code" href="structParameters_1_1parameter__value.html#s0">MValue</a> <a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>;
<a name="l00074"></a><a class="code" href="structParameters_1_1parameter__value.html#s1">00074</a>     <font class="keyword">typedef</font> std::vector&lt;parameter_value*&gt; <a class="code" href="structParameters_1_1parameter__value.html#s1">VValue</a>;
<a name="l00076"></a><a class="code" href="structParameters_1_1parameter__value.html#m1">00076</a>     std::vector&lt;parameter_value*&gt; <a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>;
<a name="l00078"></a><a class="code" href="structParameters_1_1parameter__value.html#m2">00078</a>     std::string <a class="code" href="structParameters_1_1parameter__value.html#m2">value</a>;
00079 
00080   <font class="keyword">public</font>:
<a name="l00082"></a><a class="code" href="structParameters_1_1parameter__value.html#a0">00082</a>     <a class="code" href="structParameters_1_1parameter__value.html#a0">parameter_value</a>() {}
<a name="l00085"></a><a class="code" href="structParameters_1_1parameter__value.html#a1">00085</a>     <a class="code" href="structParameters_1_1parameter__value.html#a0">parameter_value</a>( <font class="keyword">const</font> <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>&amp; other ) {
00086       <a class="code" href="structParameters_1_1parameter__value.html#m2">value</a> = other.<a class="code" href="structParameters_1_1parameter__value.html#m2">value</a>;
00087 
00088       <font class="keywordflow">for</font>( size_t i=0; i&lt;other.<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>.size(); i++ )
00089         <a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>.push_back( <font class="keyword">new</font> <a class="code" href="structParameters_1_1parameter__value.html#a0">parameter_value</a>( *other.<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>[i] ) );
00090       
00091       <font class="keywordflow">for</font>( MValue::const_iterator iter = other.<a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.begin();
00092            iter != other.<a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.end();
00093            iter++ )
00094       {
00095         <a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.insert( std::make_pair( iter-&gt;first,
00096                                       <font class="keyword">new</font> <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>( *(iter-&gt;second) ) ) );
00097       }
00098     }
<a name="l00100"></a><a class="code" href="structParameters_1_1parameter__value.html#a2">00100</a>     <a class="code" href="structParameters_1_1parameter__value.html#a2">~parameter_value</a>() {
00101       <font class="keywordflow">for</font>( std::map&lt;std::string, parameter_value*&gt;::iterator iter = <a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.begin();
00102            iter != <a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.end();
00103            iter++ )
00104       {
00105         <font class="keyword">delete</font> iter-&gt;second;
00106       }
00107 
00108       delete_vector_contents&lt;parameter_value*&gt;(array);
00109     }
<a name="l00111"></a><a class="code" href="structParameters_1_1parameter__value.html#a3">00111</a>     <font class="keywordtype">void</font> <a class="code" href="structParameters_1_1parameter__value.html#a3">convertToArray</a>() {
00112       <font class="keywordflow">if</font>( !<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>.size() &amp;&amp; ( <a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.size() || <a class="code" href="structParameters_1_1parameter__value.html#m2">value</a>.size() ) ) {
00113         <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>* child = <font class="keyword">new</font> <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>;
00114 
00115         child-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m0">table</a> = <a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>;
00116         child-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m2">value</a> = <a class="code" href="structParameters_1_1parameter__value.html#m2">value</a>;
00117 
00118         <a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.clear();
00119         <a class="code" href="structParameters_1_1parameter__value.html#m2">value</a> = <font class="stringliteral">""</font>;
00120 
00121         <a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>.push_back(child);
00122       }
00123     }
<a name="l00127"></a><a class="code" href="structParameters_1_1parameter__value.html#a4">00127</a>     <font class="keyword">const</font> std::string&amp; <a class="code" href="structParameters_1_1parameter__value.html#a4">getValue</a>() {
00128       <font class="keywordflow">if</font>( !<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>.size() )
00129         <font class="keywordflow">return</font> <a class="code" href="structParameters_1_1parameter__value.html#m2">value</a>;
00130       <font class="keywordflow">else</font>
00131         <font class="keywordflow">return</font> <a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>[0]-&gt;value;
00132     }
00133 
00134   };
00135 
00136 <font class="keyword">protected</font>:
<a name="l00137"></a><a class="code" href="classParameters.html#n0">00137</a>   <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>* <a class="code" href="classParameters.html#n0">_collection</a>;
<a name="l00138"></a><a class="code" href="classParameters.html#n1">00138</a>   <font class="keywordtype">bool</font> <a class="code" href="classParameters.html#n1">_owned</a>;
00139 
00140   <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>* <a class="code" href="classParameters.html#b0">_getRoot</a>();
00141   <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>* <a class="code" href="classParameters.html#b1">_getPath</a>( <font class="keyword">const</font> std::string&amp; path, <a class="code" href="structParameters_1_1parameter__value.html">Parameters::parameter_value</a>* last, <font class="keywordtype">int</font> offset = 0 );
00142   <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>* <a class="code" href="classParameters.html#b2">_createPath</a>( <font class="keyword">const</font> std::string&amp; path );
00143   <font class="keywordtype">void</font> <a class="code" href="classParameters.html#b3">_parseNextSegment</a>( std::string&amp; segment, <font class="keywordtype">int</font>&amp; arrayIndex, <font class="keywordtype">int</font>&amp; endOffset, <font class="keyword">const</font> std::string&amp; path, <font class="keywordtype">int</font> beginOffset );
00144   <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>* <a class="code" href="classParameters.html#b4">_getSegment</a>( <font class="keyword">const</font> std::string&amp; segment, <font class="keywordtype">int</font> arrayIndex, <a class="code" href="structParameters_1_1parameter__value.html">Parameters::parameter_value</a>* from );
00145   
00146   <font class="keywordtype">void</font> <a class="code" href="classParameters.html#b5">_loadXML</a>( <font class="keyword">class</font> <a class="code" href="classXMLNode.html">XMLNode</a>* node );
00147   <font class="keywordtype">void</font> <a class="code" href="classParameters.html#b6">_fillXML</a>( <font class="keyword">class</font> <a class="code" href="classXMLNode.html">XMLNode</a>* node );
00148   
<a name="l00149"></a><a class="code" href="classParameters.html#b7">00149</a>   INT64 <a class="code" href="classParameters.html#b7">_multiplier</a>( <font class="keyword">const</font> std::string&amp; value ) {
00150     <font class="keywordflow">if</font>( !value.length() )
00151       <font class="keywordflow">return</font> 1;
00152 
00153     <font class="keywordtype">char</font> suffix = value[ value.length()-1 ];
00154     
00155     <font class="keywordflow">switch</font>( suffix ) {
00156       <font class="keywordflow">case</font> <font class="charliteral">'K'</font>:
00157       <font class="keywordflow">case</font> <font class="charliteral">'k'</font>:
00158         <font class="keywordflow">return</font> 1000;
00159 
00160       <font class="keywordflow">case</font> <font class="charliteral">'M'</font>:
00161       <font class="keywordflow">case</font> <font class="charliteral">'m'</font>:
00162         <font class="keywordflow">return</font> 1000000;
00163 
00164       <font class="keywordflow">case</font> <font class="charliteral">'G'</font>:
00165       <font class="keywordflow">case</font> <font class="charliteral">'g'</font>:
00166         <font class="keywordflow">return</font> 1000000000;
00167     }
00168 
00169     <font class="keywordflow">return</font> 1;
00170   }
00171 
<a name="l00172"></a><a class="code" href="classParameters.html#b8">00172</a>   <font class="keywordtype">bool</font> <a class="code" href="classParameters.html#b8">_isBoolean</a>( <font class="keyword">const</font> std::string&amp; value ) {
00173     <font class="keywordflow">if</font>( !value.length() )
00174       <font class="keywordflow">return</font> <font class="keyword">false</font>;
00175 
00176     <font class="keywordtype">char</font> first = value[0];
00177     
00178     <font class="keywordflow">switch</font>(first) {
00179       <font class="keywordflow">case</font> <font class="charliteral">'Y'</font>:
00180       <font class="keywordflow">case</font> <font class="charliteral">'y'</font>:
00181       <font class="keywordflow">case</font> <font class="charliteral">'N'</font>:
00182       <font class="keywordflow">case</font> <font class="charliteral">'n'</font>:
00183       <font class="keywordflow">case</font> <font class="charliteral">'T'</font>:
00184       <font class="keywordflow">case</font> <font class="charliteral">'t'</font>:
00185       <font class="keywordflow">case</font> <font class="charliteral">'F'</font>:
00186       <font class="keywordflow">case</font> <font class="charliteral">'f'</font>:
00187         <font class="keywordflow">return</font> <font class="keyword">true</font>;
00188     }
00189 
00190     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00191   }
00192 
<a name="l00193"></a><a class="code" href="classParameters.html#b9">00193</a>   <font class="keywordtype">bool</font> <a class="code" href="classParameters.html#b9">_asBoolean</a>( <font class="keyword">const</font> std::string&amp; value ) {
00194     <font class="keywordtype">char</font> first = value[0];
00195     
00196     <font class="keywordflow">switch</font>(first) {
00197       <font class="keywordflow">case</font> <font class="charliteral">'Y'</font>:
00198       <font class="keywordflow">case</font> <font class="charliteral">'y'</font>:
00199       <font class="keywordflow">case</font> <font class="charliteral">'T'</font>:
00200       <font class="keywordflow">case</font> <font class="charliteral">'t'</font>:
00201       <font class="keywordflow">case</font> <font class="charliteral">'1'</font>:
00202          <font class="keywordflow">return</font> <font class="keyword">true</font>;
00203    
00204       <font class="keywordflow">case</font> <font class="charliteral">'F'</font>:
00205       <font class="keywordflow">case</font> <font class="charliteral">'f'</font>:
00206       <font class="keywordflow">case</font> <font class="charliteral">'N'</font>:
00207       <font class="keywordflow">case</font> <font class="charliteral">'n'</font>:
00208       <font class="keywordflow">case</font> <font class="charliteral">'0'</font>:
00209         <font class="keywordflow">return</font> <font class="keyword">false</font>;
00210     }
00211 
00212     <font class="keywordflow">return</font> <font class="keyword">false</font>;
00213   }
00214 
00215 <font class="keyword">public</font>:
00217   <a class="code" href="classParameters.html#a0">Parameters</a>();
00220   <a class="code" href="classParameters.html#a0">Parameters</a>( <font class="keyword">const</font> <a class="code" href="classParameters.html">Parameters</a>&amp; other );
00223   <a class="code" href="classParameters.html#a0">Parameters</a>( parameter_value* value );
00227   <a class="code" href="classParameters.html#a0">Parameters</a>( <font class="keyword">const</font> std::string&amp; path, parameter_value* value );
00229   <a class="code" href="classParameters.html#a4">~Parameters</a>();
<a name="l00231"></a><a class="code" href="classParameters.html#a5">00231</a>   <a class="code" href="classParameters.html#a5">operator double </a>() {
00232     <font class="keyword">const</font> std::string&amp; value = <a class="code" href="classParameters.html#b0">_getRoot</a>()-&gt;<a class="code" href="structParameters_1_1parameter__value.html#a4">getValue</a>();
00233     <font class="keywordflow">return</font> atof( value.c_str() );
00234   }
00235 
<a name="l00236"></a><a class="code" href="classParameters.html#a6">00236</a>   <a class="code" href="classParameters.html#a6">operator bool </a>() {
00237     <font class="keyword">const</font> std::string&amp; value = <a class="code" href="classParameters.html#b0">_getRoot</a>()-&gt;<a class="code" href="structParameters_1_1parameter__value.html#a4">getValue</a>();
00238     <font class="keywordflow">return</font> <a class="code" href="classParameters.html#b9">_asBoolean</a>(value);
00239   }
00240 
<a name="l00245"></a><a class="code" href="classParameters.html#a7">00245</a>   <a class="code" href="classParameters.html#a7">operator int </a>() {
00246     <font class="keyword">const</font> std::string&amp; value = <a class="code" href="classParameters.html#b0">_getRoot</a>()-&gt;<a class="code" href="structParameters_1_1parameter__value.html#a4">getValue</a>();
00247 
00248     <font class="keywordflow">if</font>( <a class="code" href="classParameters.html#b8">_isBoolean</a>(value) )
00249       <font class="keywordflow">return</font> <a class="code" href="classParameters.html#b9">_asBoolean</a>(value);
00250 
00251     <font class="keywordtype">int</font> multiplier = (int) <a class="code" href="classParameters.html#b7">_multiplier</a>( value );
00252 
00253     <font class="keywordflow">if</font>( multiplier &gt; 1 ) {
00254       std::string prefix = value.substr( 0, value.length() );
00255       <font class="keywordflow">return</font> multiplier * atoi( prefix.c_str() );
00256     }
00257 
00258     <font class="keywordflow">return</font> atoi( value.c_str() );
00259   }
00260 
<a name="l00265"></a><a class="code" href="classParameters.html#a8">00265</a>   <a class="code" href="classParameters.html#a8">operator INT64 </a>() {
00266     <font class="keyword">const</font> std::string&amp; value = <a class="code" href="classParameters.html#b0">_getRoot</a>()-&gt;<a class="code" href="structParameters_1_1parameter__value.html#a4">getValue</a>();
00267     INT64 multiplier = <a class="code" href="classParameters.html#b7">_multiplier</a>( value );
00268 
00269     <font class="keywordflow">if</font>( <a class="code" href="classParameters.html#b8">_isBoolean</a>(value) )
00270       <font class="keywordflow">return</font> <a class="code" href="classParameters.html#b9">_asBoolean</a>(value);
00271 
00272     <font class="keywordflow">if</font>( multiplier &gt; 1 ) {
00273       std::string prefix = value.substr( 0, value.length() );
00274       <font class="keywordflow">return</font> multiplier * <a class="code" href="XMLNode_8hpp.html#a1">string_to_i64</a>( prefix.c_str() );
00275     }
00276 
00277     <font class="keywordflow">return</font> <a class="code" href="XMLNode_8hpp.html#a1">string_to_i64</a>( value );
00278   }
00279 
<a name="l00281"></a><a class="code" href="classParameters.html#a9">00281</a>   operator std::string () {
00282     std::string value = <a class="code" href="classParameters.html#b0">_getRoot</a>()-&gt;<a class="code" href="structParameters_1_1parameter__value.html#a4">getValue</a>();
00283     <font class="keywordflow">return</font> value;
00284   }
00285 
<a name="l00289"></a><a class="code" href="classParameters.html#a10">00289</a>   <font class="keyword">const</font> <a class="code" href="classParameters.html">Parameters</a>&amp; operator= ( <font class="keyword">const</font> <a class="code" href="classParameters.html">Parameters</a>&amp; other ) {
00290     _collection-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m2">value</a> = other.<a class="code" href="classParameters.html#n0">_collection</a>-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m2">value</a>;
00291     
00292     <a class="code" href="delete__range_8hpp.html#a0">delete_vector_contents</a>( _collection-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a> );
00293     <a class="code" href="delete__range_8hpp.html#a1">delete_map_contents</a>( _collection-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m0">table</a> );
00294 
00295     <font class="keywordflow">for</font>( size_t i=0; i&lt;other.<a class="code" href="classParameters.html#n0">_collection</a>-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>.size(); i++ ) {
00296       _collection-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>.push_back( <font class="keyword">new</font> <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>( *other.<a class="code" href="classParameters.html#n0">_collection</a>-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m1">array</a>[i] ) );
00297     }
00298     
00299     parameter_value::MValue::iterator iter;
00300 
00301     <font class="keywordflow">for</font>( iter = other.<a class="code" href="classParameters.html#n0">_collection</a>-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.begin();
00302          iter != other.<a class="code" href="classParameters.html#n0">_collection</a>-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.end();
00303          iter++ ) {
00304       _collection-&gt;<a class="code" href="structParameters_1_1parameter__value.html#m0">table</a>.insert( std::make_pair( iter-&gt;first, 
00305                                  <font class="keyword">new</font> <a class="code" href="structParameters_1_1parameter__value.html">parameter_value</a>( *iter-&gt;second ) ) );
00306     }
00307    
00308     <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00309   }
00310 
00314   <a class="code" href="classParameters.html">Parameters</a> get( <font class="keywordtype">int</font> index );
00318   <a class="code" href="classParameters.html">Parameters</a> get( <font class="keyword">const</font> std::string&amp; name );
00322   <a class="code" href="classParameters.html">Parameters</a> get( <font class="keyword">const</font> <font class="keywordtype">char</font>* name );
00323 
00324   <font class="keywordtype">bool</font> get( <font class="keyword">const</font> std::string&amp; name, <font class="keywordtype">bool</font> def );
00330   <font class="keywordtype">int</font> get( <font class="keyword">const</font> std::string&amp; name, <font class="keywordtype">int</font> def );
00336   <font class="keywordtype">double</font> get( <font class="keyword">const</font> std::string&amp; name, <font class="keywordtype">double</font> def );
00342   INT64 get( <font class="keyword">const</font> std::string&amp; name, INT64 def );
00343   std::string get( <font class="keyword">const</font> std::string&amp; name, <font class="keyword">const</font> <font class="keywordtype">char</font>* def );
00349   std::string get( <font class="keyword">const</font> std::string&amp; name, <font class="keyword">const</font> std::string&amp; def );
00350 
00354   <a class="code" href="classParameters.html">Parameters</a> operator[] ( <font class="keywordtype">int</font> index );
00358   <a class="code" href="classParameters.html">Parameters</a> operator[] ( <font class="keyword">const</font> std::string&amp; path );
00362   <a class="code" href="classParameters.html">Parameters</a> operator[] ( <font class="keyword">const</font> <font class="keywordtype">char</font>* path );
00366   <a class="code" href="classParameters.html">Parameters</a> append( <font class="keyword">const</font> std::string&amp; path );
00370   <font class="keywordtype">void</font> remove( <font class="keyword">const</font> std::string&amp; path );
00371 
00372   <font class="keywordtype">void</font> set( <font class="keyword">const</font> std::string&amp; name, <font class="keywordtype">bool</font> value );
00373   <font class="keywordtype">void</font> set( <font class="keyword">const</font> std::string&amp; name, <font class="keyword">const</font> <font class="keywordtype">char</font>* value );
00377   <font class="keywordtype">void</font> set( <font class="keyword">const</font> std::string&amp; name, <font class="keyword">const</font> std::string&amp; value );
00381   <font class="keywordtype">void</font> set( <font class="keyword">const</font> std::string&amp; name, <font class="keywordtype">int</font> value );
00385   <font class="keywordtype">void</font> set( <font class="keyword">const</font> std::string&amp; name, UINT64 value );
00389   <font class="keywordtype">void</font> set( <font class="keyword">const</font> std::string&amp; name, <font class="keywordtype">double</font> value );
00392   <font class="keywordtype">void</font> set( <font class="keyword">const</font> std::string&amp; value );
00393 
00395   size_t <a class="code" href="TextParser_8cpp.html#a96">size</a>();
00398   <font class="keywordtype">bool</font> exists( <font class="keywordtype">int</font> index );
00401   <font class="keywordtype">bool</font> exists( <font class="keyword">const</font> std::string&amp; name );
00402 
00405   <a class="code" href="classXMLNode.html">XMLNode</a>* toXML();
00406 
00408   <font class="keyword">static</font> <a class="code" href="classParameters.html">Parameters</a>&amp; instance();
00409 
00412   <font class="keywordtype">void</font> load( <font class="keyword">const</font> std::string&amp; text );
00415   <font class="keywordtype">void</font> loadFile( <font class="keyword">const</font> std::string&amp; filename );
00419   <font class="keywordtype">void</font> loadCommandLine( <font class="keywordtype">int</font> argc, <font class="keywordtype">char</font>** argv );
00422   <font class="keywordtype">void</font> write( std::string&amp; text );
00425   <font class="keywordtype">void</font> writeFile( <font class="keyword">const</font> std::string&amp; filename );
00426 };
00427 
00428 <font class="preprocessor">#endif // INDRI_PARAMETERS_HPP</font>
</pre></div><hr><address align="right"><small>Generated on Tue Nov 16 15:17:21 2004 for INDRI by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.16 </small></address>
</body>
</html>
