/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.23
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIG_DIRECTORS

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif


#ifndef SWIG_TEMPLATE_DISAMBIGUATOR
#  if defined(__SUNPRO_CC) 
#    define SWIG_TEMPLATE_DISAMBIGUATOR template
#  else
#    define SWIG_TEMPLATE_DISAMBIGUATOR 
#  endif
#endif


#if defined(__GNUC__)
    typedef long long __int64; /*For gcc on Windows */
#endif
#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1, 
  SWIG_JavaIOException, 
  SWIG_JavaRuntimeException, 
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" } };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else

/***********************************************************************
 * director.swg
 *
 *     This file contains support for director classes that proxy
 *     method calls from C++ to Java extensions.
 *
 * Author : Scott Michel (scottm@aero.org)
 *
 * This file was adapted from the python director.swg, written by
 * Mark Rose (mrose@stm.lbl.gov)
 ************************************************************************/

#ifdef __cplusplus

namespace Swig {
  /* director base class */
  class Director {
    private:
      /* pointer to Java virtual machine */
      JavaVM *swig_jvm;

    protected:
      /* pointer to the wrapped Java object */
      jobject swig_self;

      /* Acquire Java VM environment from Java VM */
      JNIEnv *swig_acquire_jenv() const {
        JNIEnv *env = NULL;
        swig_jvm->AttachCurrentThread((void **) &env, NULL);
        return env;
      }

    public:
      Director(JNIEnv *jenv) : swig_jvm((JavaVM *) NULL), swig_self(NULL) {
        /* Acquire the Java VM pointer */
        jenv->GetJavaVM(&swig_jvm);
      }

      /* Remove the Java object global lock at destruction */
      virtual ~Director() {
        if (swig_self) {
          JNIEnv *jenv = swig_acquire_jenv();
          jmethodID disconn_meth = jenv->GetMethodID(jenv->GetObjectClass(swig_self), "swigDirectorDisconnect", "()V");
          if (disconn_meth)
            jenv->CallVoidMethod(swig_self, disconn_meth);
          jenv->DeleteGlobalRef(swig_self);
          swig_self = (jobject) NULL;
        }
      }

      /* Set swig_self and get Java global reference on object */
      void swig_set_self(JNIEnv *jenv, jobject jself) {
        swig_self = jenv->NewGlobalRef(jself);
      }

      /* return a pointer to the wrapped Java object */
      jobject swig_get_self() const {
        return swig_self; 
      }
  };
}

#endif /* __cplusplus */


namespace Swig {
  static jclass jclass_indriJNI = NULL;
  static jmethodID director_methids[1];
}

#include "indri/indri-platform.h"
#include "lemur/lemur-compat.hpp"
#include "indri/QueryEnvironment.hpp"
#include "indri/ScoredExtentResult.hpp"
#include "indri/ParsedDocument.hpp"
#include "indri/IndexEnvironment.hpp"
#include "indri/Parameters.hpp"
#include "lemur/Exception.hpp"


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


static void SWIG_JavaException(JNIEnv *jenv, int code, const char *msg) {
  SWIG_JavaExceptionCodes exception_code = SWIG_JavaUnknownError;
  switch(code) {
  case SWIG_MemoryError:
    exception_code = SWIG_JavaOutOfMemoryError;
    break;
  case SWIG_IOError:
    exception_code = SWIG_JavaIOException;
    break;
  case SWIG_SystemError:
  case SWIG_RuntimeError:
    exception_code = SWIG_JavaRuntimeException;
    break;
  case SWIG_OverflowError:
  case SWIG_IndexError:
    exception_code = SWIG_JavaIndexOutOfBoundsException;
    break;
  case SWIG_DivisionByZero:
    exception_code = SWIG_JavaArithmeticException;
    break;
  case SWIG_SyntaxError:
  case SWIG_ValueError:
  case SWIG_TypeError:
    exception_code = SWIG_JavaIllegalArgumentException;
    break;
  case SWIG_UnknownError:
  default:
    exception_code = SWIG_JavaUnknownError;
    break;
  }
  SWIG_JavaThrowException(jenv, exception_code, msg);
}
#define SWIG_exception(code, msg) { SWIG_JavaException(jenv, code, msg); }


#include <stdexcept>


#include <string>



struct jni_parseddocument_info {
  jclass pdClazz;
  jmethodID pdConstructor;

  jclass stringClazz;
  jclass byteArrayClazz;

  jclass mapClazz;
  jmethodID mapConstructor;
  jmethodID putMethod;

  jclass teClazz;
  jmethodID teConstructor;

  jfieldID termsField;
  jfieldID textField;
  jfieldID positionsField;
  jfieldID metadataField;

  jfieldID beginField;
  jfieldID endField;
};

void parseddocument_init( JNIEnv* jenv, jni_parseddocument_info& info ) {
  info.pdClazz = jenv->FindClass("edu/umass/cs/indri/ParsedDocument");
  info.pdConstructor = jenv->GetMethodID(info.pdClazz, "<init>", "()V" );

  info.stringClazz = jenv->FindClass("java/lang/String" );
  info.byteArrayClazz = jenv->FindClass("[B" );

  info.mapClazz = jenv->FindClass("java/util/HashMap");
  info.mapConstructor = jenv->GetMethodID(info.mapClazz, "<init>", "()V" );

  info.putMethod = jenv->GetMethodID(info.mapClazz, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );
  info.teClazz = jenv->FindClass("edu/umass/cs/indri/ParsedDocument$TermExtent" );
  info.teConstructor = jenv->GetMethodID(info.teClazz, "<init>", "(II)V" );

  info.textField = jenv->GetFieldID(info.pdClazz, "text", "Ljava/lang/String;" );
  info.termsField = jenv->GetFieldID(info.pdClazz, "terms", "[Ljava/lang/String;" );
  info.positionsField = jenv->GetFieldID(info.pdClazz, "positions", "[Ledu/umass/cs/indri/ParsedDocument$TermExtent;" );
  info.metadataField = jenv->GetFieldID(info.pdClazz, "metadata", "Ljava/util/Map;" );

  info.beginField = jenv->GetFieldID(info.teClazz, "begin", "I");
  info.endField = jenv->GetFieldID(info.teClazz, "end", "I");
}

jobject parseddocument_copy( JNIEnv* jenv, jni_parseddocument_info& info, ParsedDocument* doc ) {
  // make a parsed document
  jobject result = jenv->NewObject(info.pdClazz, info.pdConstructor);

  // make a metadata map to go in it
  jobject mapObject = jenv->NewObject(info.mapClazz, info.mapConstructor);

  // copy metadata information
  for( unsigned int i=0; i<doc->metadata.size(); i++ ) {
    MetadataPair& pair = doc->metadata[i];

    jstring key = jenv->NewStringUTF(pair.key);
    jbyteArray value = jenv->NewByteArray(pair.valueLength);

    jbyte* elements = jenv->GetByteArrayElements(value, 0);
    memcpy( elements, pair.value, pair.valueLength );
    jenv->ReleaseByteArrayElements(value, elements, 0);

    // put it in the map
    jenv->CallObjectMethod(mapObject, info.putMethod, key, value);
  }

  // make a terms string array
  jobjectArray termsArray = jenv->NewObjectArray(doc->terms.size(), info.stringClazz, NULL);

  // copy terms information
  for( unsigned int i=0; i<doc->terms.size(); i++ ) {
    jstring term = jenv->NewStringUTF(doc->terms[i]);
    jenv->SetObjectArrayElement(termsArray, i, term);
  }

  // make a positions array
  jobjectArray positionsArray = jenv->NewObjectArray(doc->positions.size(), info.teClazz, NULL);

  // copy positions information
  for( unsigned int i=0; i<doc->positions.size(); i++ ) {
    int begin = doc->positions[i].begin;
    int end = doc->positions[i].end;
    jobject position = jenv->NewObject(info.teClazz, info.teConstructor, begin, end);

    // add this object to the array
    jenv->SetObjectArrayElement(positionsArray, i, position);
  }

  // store field data
  jstring text = jenv->NewStringUTF(doc->text);

  jenv->SetObjectField(result, info.textField, text);
  jenv->SetObjectField(result, info.termsField, termsArray);
  jenv->SetObjectField(result, info.positionsField, positionsArray);
  jenv->SetObjectField(result, info.metadataField, mapObject);

  return result;
}




jobject java_build_queryannotationnode( QueryAnnotationNode* in,
                                   JNIEnv* jenv,
                                   jclass qanClazz,
                                   jmethodID qanConst ) {
  jobjectArray children = jenv->NewObjectArray(in->children.size(), qanClazz, NULL);

  for( unsigned int i=0; i<in->children.size(); i++ ) {
    jobject child = java_build_queryannotationnode( in->children[i], jenv, qanClazz, qanConst );
    jenv->SetObjectArrayElement(children, i, child);
  }

  jstring name = jenv->NewStringUTF(in->name.c_str());
  jstring type = jenv->NewStringUTF(in->type.c_str());
  jstring queryText = jenv->NewStringUTF(in->queryText.c_str());

  jobject node = jenv->NewObject(qanClazz, qanConst, name, type, queryText, children);

  return node;
}



jobjectArray java_build_scoredextentresult( JNIEnv* jenv, const std::vector<ScoredExtentResult>& input ) {
  jclass clazz = jenv->FindClass("edu/umass/cs/indri/ScoredExtentResult");
  jmethodID constructor = jenv->GetMethodID(clazz, "<init>", "()V" );
  jobjectArray result;

  result = jenv->NewObjectArray(input.size(), clazz, NULL);
  if (!result) {
    return 0;
  }

  jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
  jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
  jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
  jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );

  for( jsize i=0; i<input.size(); i++ ) {
    // make a new scored extent result object
    jobject ser = jenv->NewObject(clazz, constructor);

    // fill in the fields
    jenv->SetDoubleField(ser, scoreField, input[i].score );
    jenv->SetIntField(ser, beginField, input[i].begin );
    jenv->SetIntField(ser, endField, input[i].end );
    jenv->SetIntField(ser, documentField, input[i].document );

    jenv->SetObjectArrayElement(result, i, ser);
  }

  return result;
}



struct jni_parameters_info {
  jclass stringClazz;
  jclass mapClazz;
  jclass setClazz;
  jclass arrayOfMaps;
  jclass arrayOfString;
};

void java_parameters_map( JNIEnv* jenv, jni_parameters_info& info, Parameters p, jobject obj );
void java_parameters_array_of_maps( JNIEnv* jenv, jni_parameters_info& info, Parameters p, const std::string& key, jobjectArray array );

void java_parameters_init( JNIEnv* jenv, jni_parameters_info& info ) {
  info.stringClazz = jenv->FindClass("java/lang/String");
  info.mapClazz = jenv->FindClass("java/util/Map");
  info.setClazz = jenv->FindClass("java/util/Set");
  info.arrayOfMaps = jenv->FindClass("[Ljava/util/Map;");
  info.arrayOfString = jenv->FindClass("[Ljava/lang/String;");
}

void java_parameters_array_of_strings( JNIEnv* jenv, jni_parameters_info& info, Parameters p, const std::string& key, jobjectArray array ) {
  // get the array size
  jsize arrayLength = jenv->GetArrayLength(array);

  for( int i=0; i<arrayLength; i++ ) {
    jstring s = (jstring) jenv->GetObjectArrayElement( array, i );
    
    const char* valueBytes = jenv->GetStringUTFChars(s, 0);
    std::string valueString = (const char*) valueBytes;
    jenv->ReleaseStringUTFChars(s, valueBytes);
    
    p.append(key).set(valueString);
  }
}

void java_parameters_array_of_maps( JNIEnv* jenv, jni_parameters_info& info, Parameters p, const std::string& key, jobjectArray array ) {
  // get the array size
  jsize arrayLength = jenv->GetArrayLength(array);

  for( int i=0; i<arrayLength; i++ ) {
    jobject obj = jenv->GetObjectArrayElement( array, i );
    java_parameters_map( jenv, info, p, obj );
  }
}

void java_parameters_map( JNIEnv* jenv, jni_parameters_info& info, Parameters p, jobject mapObj ) {
  // get map class and entrySet method pointer
  jclass mapClazz = jenv->GetObjectClass(mapObj);
  jmethodID mapEntrySet = jenv->GetMethodID(mapClazz, "entrySet", "()Ljava/util/Set;" );

  // call entry set function to set a Set of entries
  jobject entrySet = jenv->CallObjectMethod(mapObj, mapEntrySet);
  jclass setClazz = jenv->GetObjectClass(entrySet);
  jmethodID setToArray = jenv->GetMethodID(setClazz, "toArray", "()[Ljava/lang/Object;" );

  // turn that set into an array of objects (entries)
  jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod(entrySet, setToArray);

  // get the array size
  jsize entryArrayLength = jenv->GetArrayLength(entryArray);

  for( int i=0; i<entryArrayLength; i++ ) {
    // get the key string
    jobject entryObject = (jstring) jenv->GetObjectArrayElement( entryArray, i );
    jclass mapEntryClazz = jenv->GetObjectClass(entryObject);
    jmethodID mapEntryGetKey = jenv->GetMethodID(mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
    jmethodID mapEntryGetValue = jenv->GetMethodID(mapEntryClazz, "getValue", "()Ljava/lang/Object;" );

    // get key string
    jstring key = (jstring) jenv->CallObjectMethod(entryObject, mapEntryGetKey);
    const char* bytes = jenv->GetStringUTFChars(key, 0);
    std::string keyString = (const char*) bytes;
    jenv->ReleaseStringUTFChars(key, bytes);
    
    // get value object
    jobject value = jenv->CallObjectMethod(entryObject, mapEntryGetValue);
    
    // figure out object type
    if( jenv->IsInstanceOf( value, info.stringClazz ) ) {
      const char* valueBytes = jenv->GetStringUTFChars( (jstring)value, 0);
      std::string valueString = (const char*) valueBytes;
      jenv->ReleaseStringUTFChars( (jstring)value, valueBytes);
      
      p.set( keyString, valueString );
    } else if( jenv->IsInstanceOf( value, info.mapClazz ) ) {
      Parameters sub = p.append( keyString );
      java_parameters_map( jenv, info, p, value );
    } else if( jenv->IsInstanceOf( value, info.arrayOfMaps ) ) {
      java_parameters_array_of_maps( jenv, info, p, keyString, (jobjectArray) value );
    } else if( jenv->IsInstanceOf( value, info.arrayOfString ) ) {
      java_parameters_array_of_strings( jenv, info, p, keyString, (jobjectArray) value );
    } else {
      SWIG_exception( SWIG_RuntimeError, "Found something in a Parameters parameter that wasn't a String, Map, String[] or Map[]." );
    }
  }
}




jobject documentvector_copy( JNIEnv* jenv, DocumentVector* vec ) {
  jobject result;

  jclass stringClazz = jenv->FindClass( "java/lang/String" );
  jclass docVectorClazz = jenv->FindClass( "edu/umass/cs/indri/DocumentVector" );
  jclass fieldClazz = jenv->FindClass( "edu/umass/cs/indri/DocumentVector$Field" );

  jfieldID beginField = jenv->GetFieldID( fieldClazz, "begin", "I" );
  jfieldID endField = jenv->GetFieldID( fieldClazz, "end", "I" );
  jfieldID numberField = jenv->GetFieldID( fieldClazz, "number", "J" );
  jfieldID nameField = jenv->GetFieldID( fieldClazz, "name", "Ljava/lang/String;" );

  jfieldID stemsField = jenv->GetFieldID( docVectorClazz, "stems", "[Ljava/lang/String;" );
  jfieldID positionsField = jenv->GetFieldID( docVectorClazz, "positions", "[I" );
  jfieldID fieldsField = jenv->GetFieldID( docVectorClazz, "fields", "[Ledu/umass/cs/indri/DocumentVector$Field;" );
  
  jmethodID fieldConstructor = jenv->GetMethodID( fieldClazz, "<init>", "()V" );
  jmethodID docVecConstructor = jenv->GetMethodID( docVectorClazz, "<init>", "()V" );

  int stemsCount = vec->stems().size();
  int positionsCount = vec->positions().size();
  int fieldsCount = vec->fields().size();
  
  // store positions
  jintArray posArray = jenv->NewIntArray( positionsCount );
  jint* posElements = jenv->GetIntArrayElements( posArray, 0 );

  for( int i=0; i<positionsCount; i++ ) {
    posElements[i] = vec->positions()[i];
  }

  jenv->ReleaseIntArrayElements( posArray, posElements, 0 );

  // store stems
  jobjectArray stemArray = jenv->NewObjectArray( stemsCount, stringClazz, 0 );

  for( int i=0; i<stemsCount; i++ ) {
    jstring s = jenv->NewStringUTF( vec->stems()[i].c_str() );
    jenv->SetObjectArrayElement( stemArray, i, s );
  }
  
  // store fields
  jobjectArray fieldsArray = jenv->NewObjectArray( fieldsCount, fieldClazz, 0 );
  
  for( int i=0; i<fieldsCount; i++ ) {
    // make a field object
    jobject f = jenv->NewObject( fieldClazz, fieldConstructor );
    jstring name = jenv->NewStringUTF( vec->fields()[i].name.c_str() );
    
    jenv->SetIntField( f, beginField, vec->fields()[i].begin );
    jenv->SetIntField( f, endField, vec->fields()[i].end );
    jenv->SetLongField( f, numberField, vec->fields()[i].number );
    jenv->SetObjectField( f, nameField, name );
  
    // put it in the array
    jenv->SetObjectArrayElement( fieldsArray, i, f );
  }
// don't delete this twice.
//  delete vec;
  
  // build the document vector object
  result = jenv->NewObject( docVectorClazz, docVecConstructor );

  // store fields
  jenv->SetObjectField( result, stemsField, stemArray );
  jenv->SetObjectField( result, positionsField, posArray );
  jenv->SetObjectField( result, fieldsField, fieldsArray );

  return result;
}



struct jni_specification_info {
  // Specification
  jclass specClazz;
  jmethodID specConstructor;
  jfieldID nameField;
  jfieldID parserField;
  jfieldID iteratorField;
  jfieldID startDocTagField;
  jfieldID endDocTagField;
  jfieldID endMetadataTagField;
  jfieldID includeField;
  jfieldID excludeField;
  jfieldID indexField;
  jfieldID metadataField;
  jfieldID conflationsField;
  // support classes
  jclass mapClazz;
  jmethodID mapConstructor;
  jmethodID putMethod;
};
 
 void print_info(jni_specification_info& info) 
   {
     std::cerr << info.specClazz << std::endl;
     std::cerr << info.specConstructor << std::endl;
     // get all the fields
     std::cerr << info.nameField << std::endl;
     std::cerr << info.parserField << std::endl;
     std::cerr << info.iteratorField << std::endl;
     std::cerr << info.startDocTagField << std::endl;
     std::cerr << info.endDocTagField << std::endl;
     std::cerr << info.endMetadataTagField << std::endl;
     std::cerr << info.includeField << std::endl;
     std::cerr << info.excludeField << std::endl;
     std::cerr << info.indexField << std::endl;
     std::cerr << info.metadataField << std::endl;
     std::cerr << info.conflationsField << std::endl;
     std::cerr << info.mapClazz << std::endl;
     std::cerr << info.mapConstructor << std::endl;
     std::cerr << info.putMethod << std::endl;
   }
 
void specification_init( JNIEnv* jenv, jni_specification_info& info ) {

  info.specClazz = jenv->FindClass("edu/umass/cs/indri/Specification");
  info.specConstructor = jenv->GetMethodID(info.specClazz, "<init>", "()V" );
  // get all the fields
  info.nameField = jenv->GetFieldID(info.specClazz, "name", "Ljava/lang/String;");
  info.parserField = jenv->GetFieldID(info.specClazz, "parser", "Ljava/lang/String;");
  info.iteratorField = jenv->GetFieldID(info.specClazz, "iterator", "Ljava/lang/String;");
  info.startDocTagField = jenv->GetFieldID(info.specClazz, "startDocTag", "Ljava/lang/String;");
  info.endDocTagField = jenv->GetFieldID(info.specClazz, "endDocTag", "Ljava/lang/String;");
  info.endMetadataTagField = jenv->GetFieldID(info.specClazz, "endMetadataTag", "Ljava/lang/String;");
  info.includeField = jenv->GetFieldID(info.specClazz, "include", "[Ljava/lang/String;");
  info.excludeField = jenv->GetFieldID(info.specClazz, "exclude", "[Ljava/lang/String;");
  info.indexField = jenv->GetFieldID(info.specClazz, "index", "[Ljava/lang/String;");
  info.metadataField = jenv->GetFieldID(info.specClazz, "metadata", "[Ljava/lang/String;");
  info.conflationsField = jenv->GetFieldID(info.specClazz, "conflations", "Ljava/util/Map;");

  info.mapClazz = jenv->FindClass("java/util/HashMap");
  info.mapConstructor = jenv->GetMethodID(info.mapClazz, "<init>", "()V" );
  info.putMethod = jenv->GetMethodID(info.mapClazz, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );
}

 jobjectArray string_vector_copy(JNIEnv* jenv, std::vector<std::string> &vec) {
   jclass stringClazz = jenv->FindClass("java/lang/String" );
   // fill in array  
   jobjectArray stringArray = jenv->NewObjectArray(vec.size(), stringClazz,
						   NULL);
   for(int i = 0; i < vec.size(); i++ ) {
     jstring val = jenv->NewStringUTF(vec[i].c_str());
     jenv->SetObjectArrayElement(stringArray, i, val);
   }
   return stringArray;
 }
 
 jobject specification_copy( JNIEnv* jenv, jni_specification_info& info, 
			     FileClassEnvironmentFactory::Specification* thisSpec ) {
   jobject result = jenv->NewObject(info.specClazz, info.specConstructor);
   // initialize the fields
   jstring stringField;
   stringField = jenv->NewStringUTF(thisSpec->name.c_str());
   jenv->SetObjectField(result, info.nameField, stringField);
   stringField = jenv->NewStringUTF(thisSpec->parser.c_str());
   jenv->SetObjectField(result, info.parserField, stringField);
   stringField = jenv->NewStringUTF(thisSpec->iterator.c_str());
   jenv->SetObjectField(result, info.iteratorField, stringField);
   stringField = jenv->NewStringUTF(thisSpec->startDocTag.c_str());
   jenv->SetObjectField(result, info.startDocTagField, stringField);
   stringField = jenv->NewStringUTF(thisSpec->endDocTag.c_str());
   jenv->SetObjectField(result, info.endDocTagField, stringField);
   stringField = jenv->NewStringUTF(thisSpec->endMetadataTag.c_str());
   jenv->SetObjectField(result, info.endMetadataTagField, stringField);
   // make a conflations map to go in it
   jobject mapObject = jenv->NewObject(info.mapClazz, info.mapConstructor);
   for( std::map<std::string, std::string>::iterator iter = thisSpec->conflations.begin(); 
	iter != thisSpec->conflations.end(); iter++ ) {
     const std::string &thisKey = iter->first;
     const std::string &thisVal = iter->second;
     jstring key = jenv->NewStringUTF(thisKey.c_str());
     jstring val = jenv->NewStringUTF(thisVal.c_str());
     jenv->CallObjectMethod(mapObject, info.putMethod, key, val);
   }
   jenv->SetObjectField(result, info.conflationsField, mapObject);
   jobjectArray stringArray = string_vector_copy(jenv, thisSpec->include);
   jenv->SetObjectField(result, info.includeField, stringArray);
   stringArray = string_vector_copy(jenv, thisSpec->exclude);
   jenv->SetObjectField(result, info.excludeField, stringArray);
   stringArray = string_vector_copy(jenv, thisSpec->index);
   jenv->SetObjectField(result, info.indexField, stringArray);
   stringArray = string_vector_copy(jenv, thisSpec->metadata);
   jenv->SetObjectField(result, info.metadataField, stringArray);
   return result;
 }

 // copy to string
 void copy_to_string(JNIEnv* jenv, jstring src, std::string &target) {
   jsize stringLength = jenv->GetStringUTFLength(src);
   const char* stringChars = jenv->GetStringUTFChars(src, 0);
   target.assign( stringChars, stringChars + stringLength );
 }

 // copy to string vector (stringvector.i)
 void copy_to_string_vector(JNIEnv* jenv, jobjectArray src, 
			    std::vector<std::string> &target) {
  jsize arrayLength = jenv->GetArrayLength(src);
  for( unsigned int i = 0; i < arrayLength; i++ ) {
    std::string stringCopy;
    jstring str = (jstring) jenv->GetObjectArrayElement(src, i);
    copy_to_string(jenv, str, stringCopy);    
    target.push_back(stringCopy);
  }
 }
 
 // copy to map (stringmap.i)
 void copy_to_map(JNIEnv* jenv, jobject src,
			    std::map<std::string, std::string> &map) {

  // get map class and entrySet method pointer
  jclass mapClazz = jenv->GetObjectClass(src);
  jmethodID mapEntrySet = jenv->GetMethodID(mapClazz, "entrySet", "()Ljava/util/Set;" );

  // call entry set function to set a Set of entries
  jobject entrySet = jenv->CallObjectMethod(src, mapEntrySet);
  jclass setClazz = jenv->GetObjectClass(entrySet);
  jmethodID setToArray = jenv->GetMethodID(setClazz, "toArray", "()[Ljava/lang/Object;" );

  // turn that set into an array of objects (entries)
  jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod(entrySet, setToArray);

  // get the array size
  jsize entryArrayLength = jenv->GetArrayLength(entryArray);

  for( int i=0; i<entryArrayLength; i++ ) {
    // get the key string
    jobject entryObject = (jstring) jenv->GetObjectArrayElement( entryArray, i );
    jclass mapEntryClazz = jenv->GetObjectClass(entryObject);
    jmethodID mapEntryGetKey = jenv->GetMethodID(mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
    jmethodID mapEntryGetValue = jenv->GetMethodID(mapEntryClazz, "getValue", "()Ljava/lang/Object;" );

    jobject key = jenv->CallObjectMethod( entryObject, mapEntryGetKey );
    jobject value = jenv->CallObjectMethod( entryObject, mapEntryGetValue );

    const char* keyChars = jenv->GetStringUTFChars( (jstring) key, 0 );
    std::string keyString = keyChars;
    jenv->ReleaseStringUTFChars( (jstring) key, keyChars );

    const char* valueChars = jenv->GetStringUTFChars( (jstring) value, 0 );
    std::string valueString = valueChars;
    jenv->ReleaseStringUTFChars( (jstring) value, valueChars );
    map[keyString] = valueString ;
  }
 }
 
 



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "indri_javawrap.h"

SwigDirector_IndexStatus::SwigDirector_IndexStatus(JNIEnv *jenv) : Swig::Director(jenv) {
    
}


void SwigDirector_IndexStatus::status(int code, std::string const &documentPath, std::string const &error, int documentsIndexed, int documentsSeen) {
    JNIEnv * jenv = (JNIEnv *) NULL ;
    jint jcode  ;
    jstring jdocumentPath = 0 ;
    jstring jerror = 0 ;
    jint jdocumentsIndexed  ;
    jint jdocumentsSeen  ;
    
    jenv = swig_acquire_jenv();
    if (!swig_override[0]) {
        SWIG_JavaThrowException(jenv, SWIG_JavaDirectorPureVirtual,
        "Attempted to invoke pure virtual method IndexStatus::status.");
        return;
    }
    jcode = (jint) code;
    jdocumentPath = jenv->NewStringUTF((&documentPath)->c_str()); 
    jerror = jenv->NewStringUTF((&error)->c_str()); 
    jdocumentsIndexed = (jint) documentsIndexed;
    jdocumentsSeen = (jint) documentsSeen;
    jenv->CallStaticVoidMethod(Swig::jclass_indriJNI, Swig::director_methids[0], swig_get_self(), jcode, jdocumentPath, jerror, jdocumentsIndexed, jdocumentsSeen);
    if (jenv->ExceptionOccurred()) return ;
}

void SwigDirector_IndexStatus::swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls) {
    static struct {
        const char *mname;
        const char *mdesc;
        jmethodID base_methid;
    } methods[] = {
        {
            "status", "(ILjava/lang/String;Ljava/lang/String;II)V", NULL 
        }
    };
    
    static jclass baseclass  = 0 ;
    
    swig_set_self(jenv, jself);
    if (baseclass == NULL) {
        baseclass = jenv->FindClass("edu/umass/cs/indri/IndexStatus");
        if (baseclass == NULL) return;
        baseclass = (jclass) jenv->NewGlobalRef(baseclass);
    }
    bool derived = (jenv->IsSameObject(baseclass, jcls) ? false : true);
    for (int i = 0; i < 1; ++i) {
        if (methods[i].base_methid == NULL) {
            methods[i].base_methid = jenv->GetMethodID(baseclass, methods[i].mname, methods[i].mdesc);
        }
        swig_override[i] = false;
        if (derived) {
            jmethodID methid = jenv->GetMethodID(jcls, methods[i].mname, methods[i].mdesc);
            swig_override[i] = (methid != methods[i].base_methid);
            jenv->ExceptionClear();
        }
    }
}



#ifdef __cplusplus
extern "C" {
#endif

JNIEXPORT jobject JNICALL Java_edu_umass_cs_indri_indriJNI_QueryAnnotation_1getQueryTree(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jobject jresult = 0 ;
    QueryAnnotation *arg1 = (QueryAnnotation *) 0 ;
    QueryAnnotationNode *result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryAnnotation **)&jarg1; 
    {
        try {
            result = (QueryAnnotationNode *)((QueryAnnotation const *)arg1)->getQueryTree();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        jclass qanClazz = jenv->FindClass("edu/umass/cs/indri/QueryAnnotationNode" );
        const char* signature = "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ledu/umass/cs/indri/QueryAnnotationNode;)V";
        jmethodID qanConst = jenv->GetMethodID(qanClazz, "<init>", signature );
        
        jresult = java_build_queryannotationnode( result,
        jenv,
        qanClazz,
        qanConst );
    }
    return jresult;
}


JNIEXPORT jobject JNICALL Java_edu_umass_cs_indri_indriJNI_QueryAnnotation_1getAnnotations(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jobject jresult = 0 ;
    QueryAnnotation *arg1 = (QueryAnnotation *) 0 ;
    EvaluatorNode::MResults *result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryAnnotation **)&jarg1; 
    {
        try {
            {
                EvaluatorNode::MResults const &_result_ref = ((QueryAnnotation const *)arg1)->getAnnotations();
                result = (EvaluatorNode::MResults *) &_result_ref;
            }
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        EvaluatorNode::MResults::iterator iter;
        
        // make the map
        jclass mapClazz = jenv->FindClass("java/util/HashMap");
        jmethodID mapConstructor = jenv->GetMethodID(mapClazz, "<init>", "()V" );
        jresult = jenv->NewObject(mapClazz, mapConstructor);
        jmethodID putMethod = jenv->GetMethodID(mapClazz, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );
        
        // look up information about ScoredExtentResults
        jclass seClazz = jenv->FindClass("edu/umass/cs/indri/ScoredExtentResult");
        jmethodID seConstructor = jenv->GetMethodID(seClazz, "<init>", "()V" );
        
        jfieldID scoreField = jenv->GetFieldID(seClazz, "score", "D" );
        jfieldID beginField = jenv->GetFieldID(seClazz, "begin", "I" );
        jfieldID endField = jenv->GetFieldID(seClazz, "end", "I" );
        jfieldID documentField = jenv->GetFieldID(seClazz, "document", "I" );
        
        for( iter = result->begin(); iter != result->end(); iter++ ) {
            std::vector<ScoredExtentResult>& vec = iter->second;
            
            // make an array for this list of results
            jobjectArray array = jenv->NewObjectArray(vec.size(), seClazz, NULL);
            
            for( unsigned int i=0; i<vec.size(); i++ ) {
                // make a new scored extent result object
                jobject ser = jenv->NewObject(seClazz, seConstructor);
                
                // fill in the fields
                jenv->SetDoubleField(ser, scoreField, vec[i].score );
                jenv->SetIntField(ser, beginField, vec[i].begin );
                jenv->SetIntField(ser, endField, vec[i].end );
                jenv->SetIntField(ser, documentField, vec[i].document );
                
                // add this object to the array
                jenv->SetObjectArrayElement(array, i, ser);
            }
            
            // make a java string for this result list name
            jstring key = jenv->NewStringUTF(iter->first.c_str());
            // add the java array to the map
            jenv->CallObjectMethod(jresult, putMethod, key, array);
        }
    }
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryAnnotation_1getResults(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jobjectArray jresult = 0 ;
    QueryAnnotation *arg1 = (QueryAnnotation *) 0 ;
    std::vector<ScoredExtentResult > *result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryAnnotation **)&jarg1; 
    {
        try {
            {
                std::vector<ScoredExtentResult > const &_result_ref = ((QueryAnnotation const *)arg1)->getResults();
                result = (std::vector<ScoredExtentResult > *) &_result_ref;
            }
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        jresult = java_build_scoredextentresult( jenv, *(result) );
    }
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_new_1QueryAnnotation(JNIEnv *jenv, jclass jcls) {
    jlong jresult = 0 ;
    QueryAnnotation *result;
    
    (void)jenv;
    (void)jcls;
    {
        try {
            result = (QueryAnnotation *)new QueryAnnotation();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    *(QueryAnnotation **)&jresult = result; 
    return jresult;
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_delete_1QueryAnnotation(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    QueryAnnotation *arg1 = (QueryAnnotation *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryAnnotation **)&jarg1; 
    {
        try {
            delete arg1;
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1addServer(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->addServer((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1addIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->addIndex((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1removeServer(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->removeServer((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1removeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->removeIndex((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1close(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        try {
            (arg1)->close();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1setMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    UINT64 arg2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    arg2 = (UINT64)jarg2; 
    {
        try {
            (arg1)->setMemory(arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1setScoringRules(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::vector<std::string > *arg2 = 0 ;
    std::vector<std::string > strin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        arg2 = &strin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg2->push_back(stringCopy);
        }
    }
    {
        try {
            (arg1)->setScoringRules((std::vector<std::string > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1setStopwords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::vector<std::string > *arg2 = 0 ;
    std::vector<std::string > strin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        arg2 = &strin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg2->push_back(stringCopy);
        }
    }
    {
        try {
            (arg1)->setStopwords((std::vector<std::string > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1runQuery_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jint jarg3) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    std::vector<ScoredExtentResult > result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    arg3 = (int)jarg3; 
    {
        try {
            result = (arg1)->runQuery((std::string const &)*arg2,arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        jresult = java_build_scoredextentresult( jenv, result );
    }
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1runQuery_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jintArray jarg3, jint jarg4) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<int > *arg3 = 0 ;
    int arg4 ;
    std::vector<ScoredExtentResult > result;
    std::vector<int > typemapin3 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        jsize arrayLength = jenv->GetArrayLength(jarg3);
        jint* elements = jenv->GetIntArrayElements(jarg3, 0);
        arg3 = &typemapin3;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            arg3->push_back(elements[i]);
        }
        
        jenv->ReleaseIntArrayElements(jarg3, elements, 0);
    }
    arg4 = (int)jarg4; 
    {
        try {
            result = (arg1)->runQuery((std::string const &)*arg2,(std::vector<int > const &)*arg3,arg4);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        jresult = java_build_scoredextentresult( jenv, result );
    }
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1runAnnotatedQuery_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jint jarg3) {
    jlong jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    int arg3 ;
    QueryAnnotation *result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    arg3 = (int)jarg3; 
    {
        try {
            result = (QueryAnnotation *)(arg1)->runAnnotatedQuery((std::string const &)*arg2,arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    *(QueryAnnotation **)&jresult = result; 
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1runAnnotatedQuery_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jintArray jarg3, jint jarg4) {
    jlong jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    std::vector<int > *arg3 = 0 ;
    int arg4 ;
    QueryAnnotation *result;
    std::vector<int > typemapin3 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        jsize arrayLength = jenv->GetArrayLength(jarg3);
        jint* elements = jenv->GetIntArrayElements(jarg3, 0);
        arg3 = &typemapin3;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            arg3->push_back(elements[i]);
        }
        
        jenv->ReleaseIntArrayElements(jarg3, elements, 0);
    }
    arg4 = (int)jarg4; 
    {
        try {
            result = (QueryAnnotation *)(arg1)->runAnnotatedQuery((std::string const &)*arg2,(std::vector<int > const &)*arg3,arg4);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    *(QueryAnnotation **)&jresult = result; 
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1documents_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jintArray jarg2) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::vector<int > *arg2 = 0 ;
    std::vector<ParsedDocument * > result;
    std::vector<int > typemapin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        jint* elements = jenv->GetIntArrayElements(jarg2, 0);
        arg2 = &typemapin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            arg2->push_back(elements[i]);
        }
        
        jenv->ReleaseIntArrayElements(jarg2, elements, 0);
    }
    {
        try {
            result = (arg1)->documents((std::vector<int > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        jni_parseddocument_info info;
        parseddocument_init( jenv, info );
        
        jresult = jenv->NewObjectArray((&result)->size(), info.pdClazz, NULL);
        
        for( unsigned int i=0; i<(&result)->size(); i++ ) {
            jobject document = parseddocument_copy( jenv, info, result[i] );
            jenv->SetObjectArrayElement(jresult, i, document);
            delete result[i];
        }
    }
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1documents_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::vector<ScoredExtentResult > *arg2 = 0 ;
    std::vector<ParsedDocument * > result;
    std::vector<ScoredExtentResult > resin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        jsize size = jenv->GetArrayLength(jarg2);
        
        jclass clazz = jenv->FindClass("edu/umass/cs/indri/ScoredExtentResult");
        jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
        jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
        jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
        jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
        arg2 = &resin2;
        
        for( jsize i=0; i<size; i++ ) {
            jobject seobj  = jenv->GetObjectArrayElement(jarg2, i);
            ScoredExtentResult ser;
            
            ser.begin = jenv->GetIntField(seobj, beginField);
            ser.end = jenv->GetIntField(seobj, endField);
            ser.document = jenv->GetIntField(seobj, documentField);
            ser.score = jenv->GetDoubleField(seobj, scoreField);
            
            arg2->push_back( ser );
        }
    }
    {
        try {
            result = (arg1)->documents((std::vector<ScoredExtentResult > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        jni_parseddocument_info info;
        parseddocument_init( jenv, info );
        
        jresult = jenv->NewObjectArray((&result)->size(), info.pdClazz, NULL);
        
        for( unsigned int i=0; i<(&result)->size(); i++ ) {
            jobject document = parseddocument_copy( jenv, info, result[i] );
            jenv->SetObjectArrayElement(jresult, i, document);
            delete result[i];
        }
    }
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1documentMetadata_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jintArray jarg2, jstring jarg3) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::vector<int > *arg2 = 0 ;
    std::string *arg3 = 0 ;
    SwigValueWrapper< std::vector<std::string > > result;
    std::vector<int > typemapin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        jint* elements = jenv->GetIntArrayElements(jarg2, 0);
        arg2 = &typemapin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            arg2->push_back(elements[i]);
        }
        
        jenv->ReleaseIntArrayElements(jarg2, elements, 0);
    }
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return 0;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    {
        try {
            result = (arg1)->documentMetadata((std::vector<int > const &)*arg2,(std::string const &)*arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        std::vector<std::string>& vec = result;
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jresult = jenv->NewObjectArray(vec.size(), stringClazz, NULL);
        
        for( unsigned int i=0; i<vec.size(); i++ ) {
            jstring str = jenv->NewStringUTF(vec[i].c_str());
            jenv->SetObjectArrayElement( jresult, i, str);
        }
    }
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1documentMetadata_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2, jstring jarg3) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::vector<ScoredExtentResult > *arg2 = 0 ;
    std::string *arg3 = 0 ;
    SwigValueWrapper< std::vector<std::string > > result;
    std::vector<ScoredExtentResult > resin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        jsize size = jenv->GetArrayLength(jarg2);
        
        jclass clazz = jenv->FindClass("edu/umass/cs/indri/ScoredExtentResult");
        jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
        jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
        jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
        jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
        arg2 = &resin2;
        
        for( jsize i=0; i<size; i++ ) {
            jobject seobj  = jenv->GetObjectArrayElement(jarg2, i);
            ScoredExtentResult ser;
            
            ser.begin = jenv->GetIntField(seobj, beginField);
            ser.end = jenv->GetIntField(seobj, endField);
            ser.document = jenv->GetIntField(seobj, documentField);
            ser.score = jenv->GetDoubleField(seobj, scoreField);
            
            arg2->push_back( ser );
        }
    }
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return 0;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    {
        try {
            result = (arg1)->documentMetadata((std::vector<ScoredExtentResult > const &)*arg2,(std::string const &)*arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        std::vector<std::string>& vec = result;
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jresult = jenv->NewObjectArray(vec.size(), stringClazz, NULL);
        
        for( unsigned int i=0; i<vec.size(); i++ ) {
            jstring str = jenv->NewStringUTF(vec[i].c_str());
            jenv->SetObjectArrayElement( jresult, i, str);
        }
    }
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1termCount_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    INT64 result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        try {
            result = (INT64)(arg1)->termCount();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    jresult = (jlong)result; 
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1termCount_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    jlong jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    INT64 result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            result = (INT64)(arg1)->termCount((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    jresult = (jlong)result; 
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1termFieldCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jstring jarg3) {
    jlong jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    INT64 result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return 0;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    {
        try {
            result = (INT64)(arg1)->termFieldCount((std::string const &)*arg2,(std::string const &)*arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    jresult = (jlong)result; 
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1fieldList(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    SwigValueWrapper< std::vector<std::string > > result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        try {
            result = (arg1)->fieldList();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        std::vector<std::string>& vec = result;
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jresult = jenv->NewObjectArray(vec.size(), stringClazz, NULL);
        
        for( unsigned int i=0; i<vec.size(); i++ ) {
            jstring str = jenv->NewStringUTF(vec[i].c_str());
            jenv->SetObjectArrayElement( jresult, i, str);
        }
    }
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1documentCount_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    INT64 result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        try {
            result = (INT64)(arg1)->documentCount();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    jresult = (jlong)result; 
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1documentCount_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    jlong jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    INT64 result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            result = (INT64)(arg1)->documentCount((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    jresult = (jlong)result; 
    return jresult;
}


JNIEXPORT jobjectArray JNICALL Java_edu_umass_cs_indri_indriJNI_QueryEnvironment_1documentVectors(JNIEnv *jenv, jclass jcls, jlong jarg1, jintArray jarg2) {
    jobjectArray jresult = 0 ;
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    std::vector<int > *arg2 = 0 ;
    std::vector<DocumentVector * > result;
    std::vector<int > typemapin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        jint* elements = jenv->GetIntArrayElements(jarg2, 0);
        arg2 = &typemapin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            arg2->push_back(elements[i]);
        }
        
        jenv->ReleaseIntArrayElements(jarg2, elements, 0);
    }
    {
        try {
            result = (arg1)->documentVectors((std::vector<int > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        jclass docVecClazz = jenv->FindClass( "edu/umass/cs/indri/DocumentVector" );
        jresult = jenv->NewObjectArray((&result)->size(), docVecClazz, NULL);
        
        for( unsigned int i=0; i<(&result)->size(); i++ ) {
            jobject vec = documentvector_copy( jenv, result[i] );
            jenv->SetObjectArrayElement(jresult, i, vec);
            delete result[i];
        }
    }
    return jresult;
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_new_1QueryEnvironment(JNIEnv *jenv, jclass jcls) {
    jlong jresult = 0 ;
    QueryEnvironment *result;
    
    (void)jenv;
    (void)jcls;
    {
        try {
            result = (QueryEnvironment *)new QueryEnvironment();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    *(QueryEnvironment **)&jresult = result; 
    return jresult;
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_delete_1QueryEnvironment(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    QueryEnvironment *arg1 = (QueryEnvironment *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(QueryEnvironment **)&jarg1; 
    {
        try {
            delete arg1;
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexStatus_1status(JNIEnv *jenv, jclass jcls, jlong jarg1, jint jarg2, jstring jarg3, jstring jarg4, jint jarg5, jint jarg6) {
    IndexStatus *arg1 = (IndexStatus *) 0 ;
    int arg2 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    int arg5 ;
    int arg6 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexStatus **)&jarg1; 
    arg2 = (int)jarg2; 
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return ;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    if(!jarg4) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0); 
    if (!arg4_pstr) return ;
    std::string arg4_str(arg4_pstr);
    arg4 = &arg4_str;
    jenv->ReleaseStringUTFChars(jarg4, arg4_pstr); 
    arg5 = (int)jarg5; 
    arg6 = (int)jarg6; 
    {
        try {
            (arg1)->status(arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5,arg6);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_new_1IndexStatus(JNIEnv *jenv, jclass jcls) {
    jlong jresult = 0 ;
    IndexStatus *result;
    
    (void)jenv;
    (void)jcls;
    {
        try {
            result = (IndexStatus *)new SwigDirector_IndexStatus(jenv);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    *(IndexStatus **)&jresult = result; 
    return jresult;
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexStatus_1director_1connect(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg) {
    IndexStatus *obj = *((IndexStatus **) &objarg);
    (void)jcls;
    SwigDirector_IndexStatus *director = dynamic_cast<SwigDirector_IndexStatus *>(obj);
    if (director) {
        director->swig_connect_director(jenv, jself, jenv->GetObjectClass(jself));
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_delete_1IndexStatus(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    IndexStatus *arg1 = (IndexStatus *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexStatus **)&jarg1; 
    {
        try {
            delete arg1;
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT jlong JNICALL Java_edu_umass_cs_indri_indriJNI_new_1IndexEnvironment(JNIEnv *jenv, jclass jcls) {
    jlong jresult = 0 ;
    IndexEnvironment *result;
    
    (void)jenv;
    (void)jcls;
    {
        try {
            result = (IndexEnvironment *)new IndexEnvironment();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    *(IndexEnvironment **)&jresult = result; 
    return jresult;
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_delete_1IndexEnvironment(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    {
        try {
            delete arg1;
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setAnchorTextPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jstring jarg3) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return ;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    {
        try {
            (arg1)->setAnchorTextPath((std::string const &)*arg2,(std::string const &)*arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1addFileClass_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jstring jarg3, jstring jarg4, jstring jarg5, jstring jarg6, jstring jarg7, jobjectArray jarg8, jobjectArray jarg9, jobjectArray jarg10, jobjectArray jarg11, jobjectArray jarg12) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::string *arg4 = 0 ;
    std::string *arg5 = 0 ;
    std::string *arg6 = 0 ;
    std::string *arg7 = 0 ;
    std::vector<std::string > *arg8 = 0 ;
    std::vector<std::string > *arg9 = 0 ;
    std::vector<std::string > *arg10 = 0 ;
    std::vector<std::string > *arg11 = 0 ;
    std::map<std::string,std::string > *arg12 = 0 ;
    std::vector<std::string > strin8 ;
    std::vector<std::string > strin9 ;
    std::vector<std::string > strin10 ;
    std::vector<std::string > strin11 ;
    std::map<std::string,std::string > mapin12 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return ;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    if(!jarg4) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0); 
    if (!arg4_pstr) return ;
    std::string arg4_str(arg4_pstr);
    arg4 = &arg4_str;
    jenv->ReleaseStringUTFChars(jarg4, arg4_pstr); 
    if(!jarg5) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg5_pstr = (const char *)jenv->GetStringUTFChars(jarg5, 0); 
    if (!arg5_pstr) return ;
    std::string arg5_str(arg5_pstr);
    arg5 = &arg5_str;
    jenv->ReleaseStringUTFChars(jarg5, arg5_pstr); 
    if(!jarg6) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg6_pstr = (const char *)jenv->GetStringUTFChars(jarg6, 0); 
    if (!arg6_pstr) return ;
    std::string arg6_str(arg6_pstr);
    arg6 = &arg6_str;
    jenv->ReleaseStringUTFChars(jarg6, arg6_pstr); 
    if(!jarg7) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg7_pstr = (const char *)jenv->GetStringUTFChars(jarg7, 0); 
    if (!arg7_pstr) return ;
    std::string arg7_str(arg7_pstr);
    arg7 = &arg7_str;
    jenv->ReleaseStringUTFChars(jarg7, arg7_pstr); 
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg8);
        arg8 = &strin8;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg8, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg8->push_back(stringCopy);
        }
    }
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg9);
        arg9 = &strin9;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg9, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg9->push_back(stringCopy);
        }
    }
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg10);
        arg10 = &strin10;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg10, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg10->push_back(stringCopy);
        }
    }
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg11);
        arg11 = &strin11;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg11, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg11->push_back(stringCopy);
        }
    }
    {
        // call map.entrySet()
        jclass mapClazz = jenv->GetObjectClass( jarg12 );
        jmethodID mapEntrySetMethod = jenv->GetMethodID( mapClazz, "entrySet", "()Ljava/util/Set;" );
        jobject mapEntrySet = jenv->CallObjectMethod( jarg12, mapEntrySetMethod );
        
        // call entrySet.toArray()
        jclass entrySetClazz = jenv->GetObjectClass( mapEntrySet );
        jmethodID entrySetToArrayMethod = jenv->GetMethodID( entrySetClazz, "toArray", "()[Ljava/lang/Object;" );
        jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod( mapEntrySet, entrySetToArrayMethod );
        
        // get array length
        jsize arrayLength = jenv->GetArrayLength( entryArray );
        arg12 = &mapin12;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jobject mapEntry = jenv->GetObjectArrayElement( entryArray, i );
            jclass mapEntryClazz = jenv->GetObjectClass( mapEntry );
            jmethodID mapEntryGetKeyMethod = jenv->GetMethodID( mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
            jmethodID mapEntryGetValueMethod = jenv->GetMethodID( mapEntryClazz, "getValue", "()Ljava/lang/Object;" );
            
            jobject key = jenv->CallObjectMethod( mapEntry, mapEntryGetKeyMethod );
            jobject value = jenv->CallObjectMethod( mapEntry, mapEntryGetValueMethod );
            
            const char* keyChars = jenv->GetStringUTFChars( (jstring) key, 0 );
            std::string keyString = keyChars;
            jenv->ReleaseStringUTFChars( (jstring) key, keyChars );
            
            const char* valueChars = jenv->GetStringUTFChars( (jstring) value, 0 );
            std::string valueString = valueChars;
            jenv->ReleaseStringUTFChars( (jstring) value, valueChars );
            
            mapin12[keyString] = valueString;
        }
    }
    {
        try {
            (arg1)->addFileClass((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7,(std::vector<std::string > const &)*arg8,(std::vector<std::string > const &)*arg9,(std::vector<std::string > const &)*arg10,(std::vector<std::string > const &)*arg11,(std::map<std::string,std::string > const &)*arg12);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT jobject JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1getFileClassSpec(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    jobject jresult = 0 ;
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    FileClassEnvironmentFactory::Specification *result;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return 0;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return 0;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            result = (FileClassEnvironmentFactory::Specification *)(arg1)->getFileClassSpec((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return 0;
        }
    }
    {
        // look up information about Specification
        jni_specification_info info;
        specification_init(jenv, info);
        //  print_info(info);
        jresult = specification_copy(jenv, info, result); 
        delete(result);
    }
    return jresult;
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1addFileClass_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    FileClassEnvironmentFactory::Specification *arg2 = 0 ;
    FileClassEnvironmentFactory::Specification spec2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    {
        // look up information about Specification
        jni_specification_info info;
        specification_init(jenv, info);
        
        jstring tmpString;
        jobjectArray tmpArray;
        jobject tmpMap;
        
        // string name
        tmpString = (jstring) jenv->GetObjectField(jarg2, info.nameField);
        copy_to_string(jenv, tmpString, spec2.name);
        // string parser
        tmpString = (jstring) jenv->GetObjectField(jarg2, info.parserField);
        copy_to_string(jenv, tmpString, spec2.parser);
        // string interator
        tmpString = (jstring) jenv->GetObjectField(jarg2, info.iteratorField);
        copy_to_string(jenv, tmpString, spec2.iterator);
        // string startDocTag
        tmpString = (jstring) jenv->GetObjectField(jarg2, info.startDocTagField);
        copy_to_string(jenv, tmpString, spec2.startDocTag);
        // string endDocTag
        tmpString = (jstring) jenv->GetObjectField(jarg2, info.endDocTagField);
        copy_to_string(jenv, tmpString, spec2.endDocTag);
        // string endMetadataTag
        tmpString = (jstring) jenv->GetObjectField(jarg2, info.endMetadataTagField);
        copy_to_string(jenv, tmpString, spec2.endMetadataTag);
        // vector<string> include 
        tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.includeField);
        copy_to_string_vector(jenv, tmpArray, spec2.include);
        // vector<string> exclude
        tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.excludeField);
        copy_to_string_vector(jenv, tmpArray, spec2.exclude);
        // vector<string> index
        tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.indexField);
        copy_to_string_vector(jenv, tmpArray, spec2.index);
        // vector<string> metadata
        tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.metadataField);
        copy_to_string_vector(jenv, tmpArray, spec2.metadata);
        // map<string, string> conflations 
        tmpMap = (jobject) jenv->GetObjectField(jarg2, info.conflationsField);
        copy_to_map(jenv, tmpMap, spec2.conflations);
        
        arg2 = &spec2;
    }
    {
        try {
            (arg1)->addFileClass((FileClassEnvironmentFactory::Specification const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setIndexedFields(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::vector<std::string > *arg2 = 0 ;
    std::vector<std::string > strin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        arg2 = &strin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg2->push_back(stringCopy);
        }
    }
    {
        try {
            (arg1)->setIndexedFields((std::vector<std::string > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setNumericField(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jboolean jarg3) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    bool arg3 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    arg3 = jarg3 ? true : false; 
    {
        try {
            (arg1)->setNumericField((std::string const &)*arg2,arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setMetadataIndexedFields(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::vector<std::string > *arg2 = 0 ;
    std::vector<std::string > strin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        arg2 = &strin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg2->push_back(stringCopy);
        }
    }
    {
        try {
            (arg1)->setMetadataIndexedFields((std::vector<std::string > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setStopwords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobjectArray jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::vector<std::string > *arg2 = 0 ;
    std::vector<std::string > strin2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    {
        jclass stringClazz = jenv->FindClass("java/lang/String");
        jsize arrayLength = jenv->GetArrayLength(jarg2);
        arg2 = &strin2;
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
            jsize stringLength = jenv->GetStringUTFLength(str);
            const char* stringChars = jenv->GetStringUTFChars(str, 0);
            std::string stringCopy;
            stringCopy.assign( stringChars, stringChars + stringLength );
            arg2->push_back(stringCopy);
        }
    }
    {
        try {
            (arg1)->setStopwords((std::vector<std::string > const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setStemmer(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->setStemmer((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jlong jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    UINT64 arg2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    arg2 = (UINT64)jarg2; 
    {
        try {
            (arg1)->setMemory(arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1setNormalization(JNIEnv *jenv, jclass jcls, jlong jarg1, jboolean jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    bool arg2 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    arg2 = jarg2 ? true : false; 
    {
        try {
            (arg1)->setNormalization(arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1create_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jlong jarg3) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    IndexStatus *arg3 = (IndexStatus *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    arg3 = *(IndexStatus **)&jarg3; 
    {
        try {
            (arg1)->create((std::string const &)*arg2,arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1create_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->create((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1open_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jlong jarg3) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    IndexStatus *arg3 = (IndexStatus *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    arg3 = *(IndexStatus **)&jarg3; 
    {
        try {
            (arg1)->open((std::string const &)*arg2,arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1open_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->open((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1close(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    {
        try {
            (arg1)->close();
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1addFile_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    {
        try {
            (arg1)->addFile((std::string const &)*arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1addFile_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jstring jarg3) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return ;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    {
        try {
            (arg1)->addFile((std::string const &)*arg2,(std::string const &)*arg3);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1addString(JNIEnv *jenv, jclass jcls, jlong jarg1, jstring jarg2, jstring jarg3, jobjectArray jarg4) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    std::string *arg2 = 0 ;
    std::string *arg3 = 0 ;
    std::vector<MetadataPair > *arg4 = 0 ;
    std::vector<MetadataPair > mdin4 ;
    Buffer mdbuf4 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    if(!jarg2) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
    if (!arg2_pstr) return ;
    std::string arg2_str(arg2_pstr);
    arg2 = &arg2_str;
    jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
    if(!jarg3) {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
        return ;
    }
    const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
    if (!arg3_pstr) return ;
    std::string arg3_str(arg3_pstr);
    arg3 = &arg3_str;
    jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
    {
        // call map.entrySet()
        jclass mapClazz = jenv->GetObjectClass( jarg4 );
        jmethodID mapEntrySetMethod = jenv->GetMethodID( mapClazz, "entrySet", "()Ljava/util/Set;" );
        jobject mapEntrySet = jenv->CallObjectMethod( jarg4, mapEntrySetMethod );
        
        // call entrySet.toArray()
        jclass entrySetClazz = jenv->GetObjectClass( mapEntrySet );
        jmethodID entrySetToArrayMethod = jenv->GetMethodID( entrySetClazz, "toArray", "()[Ljava/lang/Object;" );
        jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod( mapEntrySet, entrySetToArrayMethod );
        
        // get array length
        jsize arrayLength = jenv->GetArrayLength( entryArray );
        arg4 = &mdin4;
        
        jclass stringClazz = jenv->FindClass("edu/java/lang/String");
        
        for( unsigned int i=0; i<arrayLength; i++ ) {
            jobject mapEntry = jenv->GetObjectArrayElement( entryArray, i );
            jclass mapEntryClazz = jenv->GetObjectClass( mapEntry );
            jmethodID mapEntryGetKeyMethod = jenv->GetMethodID( mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
            jmethodID mapEntryGetValueMethod = jenv->GetMethodID( mapEntryClazz, "getValue", "()Ljava/lang/Object;" );
            
            jobject key = jenv->CallObjectMethod( mapEntry, mapEntryGetKeyMethod );
            jobject value = jenv->CallObjectMethod( mapEntry, mapEntryGetValueMethod );
            
            const char* keyChars = jenv->GetStringUTFChars( (jstring) key, 0 );
            jsize keyLength = jenv->GetStringUTFLength( (jstring) key);
            std::string keyString = keyChars;
            char* keyPosition = mdbuf4.write( keyLength+1 );
            strncpy( keyPosition, keyChars, keyLength );
            keyPosition[keyLength] = 0;
            char* valuePosition = 0;
            jsize valueLength;
            
            if( jenv->IsInstanceOf( value, stringClazz ) ) {
                jstring valueString = (jstring) value;
                const char* valueChars = jenv->GetStringUTFChars( valueString, 0);
                valueLength = jenv->GetStringUTFLength( valueString );
                
                valuePosition = mdbuf4.write( valueLength+1 );
                strncpy( valuePosition, valueChars, valueLength );
                valuePosition[valueLength] = 0;
                valueLength++;
                
                jenv->ReleaseStringUTFChars(valueString, valueChars);
            } else {
                // is byte array
                jbyteArray valueArray = (jbyteArray) value;
                jbyte* valueBytes = jenv->GetByteArrayElements( valueArray, 0 );
                valueLength = jenv->GetArrayLength( valueArray );
                
                valuePosition = mdbuf4.write( valueLength+1 );
                memcpy( valuePosition, valueBytes, valueLength );
                valuePosition[valueLength] = 0;
                
                jenv->ReleaseByteArrayElements(valueArray, valueBytes, 0);
            }
            
            MetadataPair pair;
            pair.key = keyPosition;
            pair.value = valuePosition;
            pair.valueLength = valueLength;
            mdin4.push_back(pair);
            
            jenv->ReleaseStringUTFChars( (jstring)key, keyChars);
        }
    }
    {
        try {
            (arg1)->addString((std::string const &)*arg2,(std::string const &)*arg3,(std::vector<MetadataPair > const &)*arg4);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_IndexEnvironment_1addParsedDocument(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg2) {
    IndexEnvironment *arg1 = (IndexEnvironment *) 0 ;
    ParsedDocument *arg2 = (ParsedDocument *) 0 ;
    
    (void)jenv;
    (void)jcls;
    arg1 = *(IndexEnvironment **)&jarg1; 
    arg2 = *(ParsedDocument **)&jarg2; 
    {
        try {
            (arg1)->addParsedDocument(arg2);
            
        } catch( Exception& e ) {
            SWIG_exception( SWIG_RuntimeError, e.what().c_str() );
            // control does not leave method when thrown.
            return ;
        }
    }
}


JNIEXPORT void JNICALL Java_edu_umass_cs_indri_indriJNI_swig_1module_1init(JNIEnv *jenv, jclass jcls) {
    int i;
    
    static struct {
        const char *method;
        const char *signature;
    } methods[1] = {
        {
            "SwigDirector_IndexStatus_status", "(Ledu/umass/cs/indri/IndexStatus;ILjava/lang/String;Ljava/lang/String;II)V" 
        }
    };
    Swig::jclass_indriJNI = (jclass) jenv->NewGlobalRef(jcls);
    if (Swig::jclass_indriJNI == NULL) return;
    for (i = 0; i < (int) (sizeof(methods)/sizeof(methods[0])); ++i) {
        Swig::director_methids[i] = jenv->GetStaticMethodID(jcls, methods[i].method, methods[i].signature);
        if (Swig::director_methids[i] == NULL) return;
    }
}


#ifdef __cplusplus
}
#endif

